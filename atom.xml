<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BiG哥|博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/SpringEE/SpringEE.github.io/"/>
  <updated>2018-12-16T03:22:18.535Z</updated>
  <id>https://github.com/SpringEE/SpringEE.github.io/</id>
  
  <author>
    <name>BiG哥|博客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo整合springboot</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2018/02/23/Dubbo%E5%AE%9E%E6%88%98%20%E6%95%B4%E5%90%88%20SpringBoot%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2018/02/23/Dubbo实战 整合 SpringBoot 实现自动装配/</id>
    <published>2018-02-23T11:08:20.000Z</published>
    <updated>2018-12-16T03:22:18.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如今 <code>Spring Boot</code> 在微服务领域已十分风靡，开箱即用的特性，简化了很多开发工作。而 <code>Dubbo</code> 在 <code>2017</code> 年重新得到维护以后，社区逐渐活跃，<code>Dubbo RPC</code> 十分优秀，本文我们将通过一个例子来构建一个基于 <code>Spring Boot</code> 的<code>Dubbo</code> 微服务工程。</p></blockquote><h3 id="Dubbo-Spring-Boot-Starter-项目"><a href="#Dubbo-Spring-Boot-Starter-项目" class="headerlink" title="Dubbo Spring Boot Starter 项目"></a>Dubbo Spring Boot Starter 项目</h3><blockquote><p>我们在采用 <code>Dubbo</code> 作为 微服务框架时，可以通过依赖这个项目来轻松整合 <code>SpringBoot</code></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/6393906-5a4c995a12ed2093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="dubbo-spring-boot.png"></p><p>上面是 Dubbo Spring Boot 工程地址 。<a href="https://github.com/alibaba/dubbo">Dubbo</a> Spring Boot 工程致力于简化 Dubbo RPC 框架在 <a href="https://github.com/spring-projects/spring-boot/">Spring Boot</a> 应用场景的开发。同时也整合了 Spring Boot 特性：</p><h3 id="SpringBoot-Dubbo-项目实战"><a href="#SpringBoot-Dubbo-项目实战" class="headerlink" title="SpringBoot Dubbo 项目实战"></a>SpringBoot Dubbo 项目实战</h3><blockquote><p>我们将实现一个简单的基于SpringBoot 和 Dubbo 的微服务例子来进行讲解。<br>项目采用多模块的形式打包。分为如下三个工程：</p><ul><li>dubbo-boot-api<br>统一使用的API工程，提供给生产者和消费者，包括服务接口等，实体模型等。</li><li>dubbo-boot-consumer<br>服务消费端，该工程将会提供web服务，并调用 Dubbo 提供的微服务。</li><li>dubbo-boot-provider<br>服务提供方，提供服务供消费者进行调用</li></ul></blockquote><h3 id="POM-依赖"><a href="#POM-依赖" class="headerlink" title="POM 依赖"></a>POM 依赖</h3><blockquote><p>项目根 <code>POM</code> 文件 需要依赖 SpringBoot 的 Parent 工程 作为 父工程以方便管理Spring的版本，我们采用的版本号为 <code>Spring Boot 2.0.0.RELEASE</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div></pre></td></tr></table></figure></p><p>服务提供者 (<code>dubbo-boot-provider</code>) 、服务消费者 (<code>dubbo-boot-consumer</code>)  都需要依赖 <code>dubbo</code> 整合 <code>Spring</code> 的<code>dubbo-spring-boot-starter</code>工程，以及 <code>spring-boot-starter-web</code>，通过 <code>web</code> 作为服务启动运行载体。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Dubbo 整合 Boot Dubbo 依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Spring Boot Web 依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p></blockquote><h3 id="API-工程-dubbo-boot-api"><a href="#API-工程-dubbo-boot-api" class="headerlink" title="API 工程 dubbo-boot-api"></a>API 工程 <code>dubbo-boot-api</code></h3><blockquote><p>api工程主要提供实体类和公用服务接口， <code>provider</code>、<code>consumer</code> 都会依赖它</p></blockquote><p>实体类 <code>City</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> String from;</div></pre></td></tr></table></figure></p><p>服务接口 <code>CityService</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityService</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根据城市名称，查询城市信息</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> cityName</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">City <span class="title">findCityByName</span><span class="params">(String cityName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Provider-服务提供工程-dubbo-boot-provider"><a href="#Provider-服务提供工程-dubbo-boot-provider" class="headerlink" title="Provider 服务提供工程 dubbo-boot-provider"></a>Provider 服务提供工程 <code>dubbo-boot-provider</code></h3><p>服务提供实现 <code>CityServiceImpl</code><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span>(</div><div class="line">        version = <span class="string">"$&#123;demo.service.version&#125;"</span>,</div><div class="line">        application = <span class="string">"$&#123;dubbo.application.id&#125;"</span>,</div><div class="line">        protocol = <span class="string">"$&#123;dubbo.protocol.id&#125;"</span>,</div><div class="line">        registry = <span class="string">"$&#123;dubbo.registry.id&#125;"</span></div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityServiceImpl</span> <span class="keyword">implements</span> <span class="title">CityService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">findCityByName</span><span class="params">(String cityName)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"request cityName: "</span> + cityName);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> City(<span class="string">"武汉"</span>, <span class="string">"湖北"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>启动类 <code>AppProvider</code></p><blockquote><p>使用非 <code>web</code> 的形式启动 <code>SpringBoot</code> 容器，提供 <code>Dubbo Rpc</code> 服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableDubboConfiguration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">          <span class="comment">//使用非 Web 环境启动 Spring容器，提供dubbo rpc 服务</span></div><div class="line">           <span class="keyword">new</span> SpringApplicationBuilder().sources(AppProvider.class)</div><div class="line">                .web(WebApplicationType.NONE)</div><div class="line">                .run(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># Spring boot application</div><div class="line">spring.application.name = dubbo-provider-demo</div><div class="line"></div><div class="line">## Provider类配置</div><div class="line">demo.service.version=1.0.0</div><div class="line">dubbo.application.id = dubbo-boot-provider</div><div class="line">dubbo.application.name = dubbo-boot-provider</div><div class="line"></div><div class="line">## 使用通讯协议、暴露端口</div><div class="line">dubbo.protocol.id = dubbo</div><div class="line">dubbo.protocol.name = dubbo</div><div class="line">dubbo.protocol.port = 20880</div><div class="line"></div><div class="line">## 注册中心 （不使用，直接本地互连）</div><div class="line">dubbo.registry.id = my-registry</div><div class="line">dubbo.registry.address = N/A</div></pre></td></tr></table></figure><h3 id="Consumer-消费者工程-dubbo-boot-provider"><a href="#Consumer-消费者工程-dubbo-boot-provider" class="headerlink" title="Consumer 消费者工程 dubbo-boot-provider"></a>Consumer 消费者工程 <code>dubbo-boot-provider</code></h3><blockquote><p><code>Spring Boot</code> <code>Controller</code> 类，提供 <code>Rest</code> 接口。引用 <code>Dubbo</code> 服务接口 <code>CityService</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Reference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>,</div><div class="line">            application = <span class="string">"$&#123;dubbo.application.id&#125;"</span>,</div><div class="line">            url = <span class="string">"$&#123;dubbo.service.url&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> CityService cityService;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cityService.findCityByName(<span class="string">"武汉"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><blockquote><p>提供 <code>web</code> 服务供前端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumerServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(AppConsumerServer.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><h4 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h4><blockquote><p>本例子没有采用注册中心，而是通过本地 <code>url</code> 互相直连服务端进行调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring.application.name=dubbo-boot-consumer</div><div class="line"></div><div class="line">demo.service.version=1.0.0</div><div class="line"></div><div class="line">dubbo.application.id=dubbo-boot-consumer</div><div class="line">dubbo.application.name=dubbo-boot-consumer</div><div class="line"></div><div class="line"># 通过直连方式</div><div class="line">dubbo.service.url=dubbo://127.0.0.1:20880</div></pre></td></tr></table></figure></p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>分别运行启动服务端(<code>AppServer</code>) 和消费端(<code>AppConsumerServer</code>) 类。然后打开浏览器访问 <code>localhost:8080/hello</code><br><img src="https://upload-images.jianshu.io/upload_images/6393906-c9fecdee1b122e3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="调用结果.png"></p><p>结果显示已经调用成功。整个执行链为，前端访问 <code>url</code> 调用消费端 <code>Spring Rest</code>接口，<code>Controller</code> 里通过 <code>Dubbo Rpc</code> 调用 服务端提供的服务，然后返回。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用 <code>Spring Boot</code> 工程，引入 <code>Dubbo</code> 整合 <code>Spring Boot</code> 的 依赖，将会使我们非常简单轻松的使用 <code>Dubbo</code> 来提供微服务。我们可以充分利用 <code>Spring Boot</code> 的 注解驱动、自动装配、外部化配置、<code>Actuator</code> 监控等特性，来轻松管理基于<code>Dubbo</code> 的微服务。</p><p>社区提供的 <code>dubbo-spring-boot-starter</code> 工程 整合了与 <code>Spring Boot</code> 这些自动配置、依赖等。所以下一步我们将会研究 它是如何实现与 <code>Spring Boot</code> 无缝整合的。</p><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p>最后推荐一下本人微信公众号，欢迎大家关注。</p><p><img src="https://upload-images.jianshu.io/upload_images/6393906-47e180d949563b81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如今 &lt;code&gt;Spring Boot&lt;/code&gt; 在微服务领域已十分风靡，开箱即用的特性，简化了很多开发工作。而 &lt;code&gt;Dubbo&lt;/code&gt; 在 &lt;code&gt;2017&lt;/code&gt; 年重新得到维护以后，社区逐渐活跃，&lt;code&gt;Du
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebSocket消息推送Demo</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2018/02/20/WebSocket/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2018/02/20/WebSocket/</id>
    <published>2018-02-20T08:27:29.000Z</published>
    <updated>2018-06-20T10:15:58.310Z</updated>
    
    <content type="html"><![CDATA[<p>  <a href="https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin" target="_blank" rel="external">WebSocket</a>协议是基于TCP的一种新的网络协议。WebSocket的出现主要是针对于解决Http请求单向请求应答的问题，针对于传统的“长轮询”局限性，WebSocket让服务端具备了主动消息推送的功能，不必等待客户端的请求，便能实现实时的消息推送。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Websocket是html5提出的一个协议规范，为解决传统“长轮询”多次http请求问题而诞生，使得客户端与服务端建立连接后，服务端具备主动给客户端推送消息的功能，不必再让客户端走传统的请求应答模式。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>WebSocket解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮询问题。（有点类似于观察者模式）；  </li><li>websocket是一种双向通信协议，采用异步回调的方式接受消息，当建立通信连接，可以做到持久性的连接，并进行通信；  </li><li>WebSocket需要通过握手连接，类似于TCP它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。  </li><li>建立连接后，WebSocket服务器和Browser都能主动的向对方发送或接收数据，实质的推送方式是服务器主动推送，只要有数据就推送到请求方。（变被动为主动）  <h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></li></ol><ul><li>第一步： 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行；  </li><li>第二步： TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）  </li><li>第三步： 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。    </li><li>第四步： 当收到了连接成功的消息后，通过TCP通道进行传输通信,并将通讯协议升级为“WebSocket协议”，从此不再使用HTTP协议，仅第一次请求时使用已建立连接。  </li></ul><h2 id="Http和WebSocket异同"><a href="#Http和WebSocket异同" class="headerlink" title="Http和WebSocket异同"></a>Http和WebSocket异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都是基于TCP的应用层协议；    </li><li>都使用Request/Response模型进行连接的建立；   </li><li>都可以在网络中传输数据；  </li><li>在连接的建立过程中对错误的处理方式相同，在这个阶段WebSocket可能返回和HTTP相同的返回码；  <h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3></li></ol><ul><li>http协议基于请求应答，只能做单向传输，是半双工协议，而WebSocket是全双工协议，类似于socket通信，双方都可以在任何时刻向另一方发送数据；  </li><li>WebSocket的连接不能通过中间人来转发，它必须是一个直接连接。如果通过代理转发，一个代理要承受如此多的websocket连接不释放，就类似于一次DDOS攻击了；  </li><li>WebSocket在建立握手连接时，数据是通过http协议传输的，但在建立连接之后，真正的数据传输阶段是不需要http协议参与的；  </li><li>websocket传输的数据是二进制流，是以帧为单位的，http传输的是明文传输，是字符串传输，WebSocket的数据帧有序；</li></ul><h2 id="WebSocket实用Demo"><a href="#WebSocket实用Demo" class="headerlink" title="WebSocket实用Demo"></a>WebSocket实用Demo</h2><h3 id="01-注册WebSocket"><a href="#01-注册WebSocket" class="headerlink" title="01-注册WebSocket"></a>01-注册WebSocket</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-576416360c0d0c71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png">  </p><h3 id="02-创建连接"><a href="#02-创建连接" class="headerlink" title="02-创建连接"></a>02-创建连接</h3><ul><li>客户端<br><img src="https://upload-images.jianshu.io/upload_images/9194313-fac06fdb6d98c7a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"><br><strong>websocket常用方法：</strong><br><code>websocket.onopen=function(){}  //连接成功建立的回调方法</code><br><code>websocket.send(message)        //客户端向服务端发送消息</code><br><code>websocket.onmessage=function(event){}  //接受服务端消息后的回调</code><br><code>websocket.close()        //客户端向服务端发送消息</code><br><code>websocket.onclose=function(){}  //连接关闭的回调方法</code><br><code>websocket.onerror=function(){}  //连接出错的回调方法</code>  </li><li>服务端<br><img src="https://upload-images.jianshu.io/upload_images/9194313-0065ffdfa8ec15bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br><strong>websocket常用注解：</strong><br><code>@OnOpen  //连接建立成功，接受客户端数据</code><br><code>@OnMessage  //收到客户端消息后的逻辑处理方法</code><br><code>@OnClose  //连接关闭，处理业务逻辑</code><br><code>@OnError  //服务端连接出错，调用逻辑</code><br><strong>服务端响应数据：</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-e773a432b220d5f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"></li></ul><p><a href="https://pan.baidu.com/s/1KnfMn3_rxLP7hSGCQi9_qw" target="_blank" rel="external">源码链接:</a><a href="https://pan.baidu.com/s/1KnfMn3_rxLP7hSGCQi9_qw" target="_blank" rel="external">https://pan.baidu.com/s/1KnfMn3_rxLP7hSGCQi9_qw</a></p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;a href=&quot;https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WebSocket&lt;/a&gt;协议是基于TCP的一种新的网络协议。WebSocket的出现主要是针对于解决Http请求单向请求应答的问题，针对于传统的“长轮询”局限性，WebSocket让服务端具备了主动消息推送的功能，不必等待客户端的请求，便能实现实时的消息推送。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ssh全注解Demo（含源码下载链接）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2018/01/14/ssh_demo/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2018/01/14/ssh_demo/</id>
    <published>2018-01-14T15:52:20.000Z</published>
    <updated>2018-05-28T08:42:34.844Z</updated>
    
    <content type="html"><![CDATA[<p>   ssh全注解demo,前台通过request获取传递的参数，后台通过Utils4View将返回数据进行封装处理。涉及到的配置文件主要是以下几个：applicationContext.xml/struts.xml/jdbc.properties等，直接复制修改即可，主要是替换扫包路径和数据库连接。</p><a id="more"></a><h3 id="项目结构包"><a href="#项目结构包" class="headerlink" title="项目结构包"></a>项目结构包</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-d1729464eb2e0f72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"> </p><h3 id="Action层："><a href="#Action层：" class="headerlink" title="Action层："></a>Action层：</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-4413e0d9138dbc18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-c57a49c2dd6abc91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><h3 id="POJO类"><a href="#POJO类" class="headerlink" title="POJO类"></a>POJO类</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-6ac85c13819f637d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"></p><h3 id="前台index-jsp"><a href="#前台index-jsp" class="headerlink" title="前台index.jsp"></a>前台index.jsp</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-98b30c25573d7a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"></p><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-20dc8a1c5c92eae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"></p><p><a href="https://pan.baidu.com/s/1q6fHhlhUIh3uCjsszMrgzA" target="_blank" rel="external">项目源码下载</a>：<a href="https://pan.baidu.com/s/1q6fHhlhUIh3uCjsszMrgzA" target="_blank" rel="external">https://pan.baidu.com/s/1q6fHhlhUIh3uCjsszMrgzA</a></p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   ssh全注解demo,前台通过request获取传递的参数，后台通过Utils4View将返回数据进行封装处理。涉及到的配置文件主要是以下几个：applicationContext.xml/struts.xml/jdbc.properties等，直接复制修改即可，主要是替换扫包路径和数据库连接。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>贯穿JS、java、mysql的所有日期操作</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/12/29/TimeCompare/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/12/29/TimeCompare/</id>
    <published>2017-12-29T15:52:20.000Z</published>
    <updated>2018-05-29T01:06:37.499Z</updated>
    
    <content type="html"><![CDATA[<p>   目前，因为公司开发使用的ssm框架，从前端js到后台java，以及mysql数据库，只要涉及到时间处理的问题，都难免会遇到日期获取、格式化、比较大小等操作，而且目前的博客都只针对单方面做了讲解，此文将决定做统一归纳汇总，以方便读者保存和分享。</p><a id="more"></a><h2 id="JS-时间日期操作"><a href="#JS-时间日期操作" class="headerlink" title="JS-时间日期操作"></a>JS-时间日期操作</h2><h3 id="日期获取"><a href="#日期获取" class="headerlink" title="日期获取"></a>日期获取</h3><p>获取时间：<br><code>var myDate = new Date();//获取系统当前时间</code><br><code>var d2=new Date(1320336000000);//这个参数就是时间戳，被视为毫秒</code><br><code>var d3=new Date(&quot;2013-8-20 18:20:30&quot;);//字符串，并能够使用Date.parse()转换</code><br><code>var d4=new Date(2013,7,26);//参数含义参照d5参数描述</code><br><code>var d5=new Date(year, month, day, hours, minutes, seconds, microseconds)</code><br>获取指定时间数据：<br><code>var myDate = new Date();</code><br><code>myDate.getYear(); //获取当前年份(2位)</code><br><code>myDate.getFullYear(); //获取完整的年份(4位,1970-????)</code><br><code>myDate.getMonth(); //获取当前月份(0-11,0代表1月)</code><br><code>myDate.getDate(); //获取当前日(1-31)</code><br><code>myDate.getDay(); //获取当前星期X(0-6,0代表星期天)</code><br><code>myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)</code><br><code>myDate.getHours(); //获取当前小时数(0-23)</code><br><code>myDate.getMinutes(); //获取当前分钟数(0-59)</code><br><code>myDate.getSeconds(); //获取当前秒数(0-59)</code><br><code>myDate.getMilliseconds(); //获取当前毫秒数(0-999)</code><br><code>myDate.toLocaleDateString(); //获取当前日期</code><br><code>var mytime=myDate.toLocaleTimeString(); //获取当前时间</code><br><code>myDate.toLocaleString( ); //获取日期与时间</code><br>获取时间戳：<br><code>var myDate = new Date(&quot;2013-8-20 18:20:30&quot;).getTime();//获取系统当前时间</code><br><code>var myDate = new Date().getTime();//获取系统当前时间</code><br><code>var myDate = new Date(&quot;2013/5/12 20:10:20&quot;).getTime();//获取系统当前时间</code><br><code>--“/”和“-”的区别在于时区的问题，使用“/”所获取的时间戳更为准确</code><br><code>Date.parse(&quot;2013/5/12 20:10:20&quot;);//用于分析一个包含日期的字符串,返回一个时间戳</code>  </p><h3 id="日期转字符串："><a href="#日期转字符串：" class="headerlink" title="日期转字符串："></a>日期转字符串：</h3><p><code>var testDate = new Date();</code><br><code>var dateobj_toString = testDate.toString();//toString() 把Date对象转换为字符串。</code><br><code>var dataobj_toTimeString = testDate.toTimeString();//toTimeString()把Date对象的时间部分转换为字符串。</code><br><code>var dateobj_toDateString = testDate.toDateString();//toDateString()把Date对象的日期部分转换为字符串。</code><br><code>var dateobj_toUTCString = testDate.toUTCString();//toUTCString()根据世界时，Date对象转换为字符串。</code><br><code>var dateobj_toLocalString = testDate.toLocaleString();//toLocaleString()根据本地时间格式，把Date对象转换为字符串。</code><br><code>var dateobj_toLocalTimeString = testDate.toLocaleTimeString(); // toLocaleTimeString()根据本地时间格式，把Date对象的时间部分转换为字符串。</code><br><code>var dateobj_toLocaleDateString = testDate.toLocaleDateString();//toLocaleDateString()根据本地时间格式，把Date对象的日期部分转换为字符串。</code><br><img src="https://upload-images.jianshu.io/upload_images/9194313-55d9d88c875bc455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.pgn"></p><h3 id="日期格式化："><a href="#日期格式化：" class="headerlink" title="日期格式化："></a>日期格式化：</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-858fb1683f40ba29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"><br>使用案例：<br><code>(new Date()).Format(&quot;yyyy-MM-dd hh:mm:ss&quot;) //输出结果： 2017-01-23 09:36:10</code><br><code>(new Date()).Format(&quot;yyyy-MM-dd&quot;) //输出结果： 2017-01-23</code><br>可参考链接，拷贝代码：<a href="https://www.cnblogs.com/linJie1930906722/p/6343337.html" target="_blank" rel="external">链接地址</a></p><h2 id="JAVA-时间日期操作"><a href="#JAVA-时间日期操作" class="headerlink" title="JAVA-时间日期操作"></a>JAVA-时间日期操作</h2><h3 id="日期获取-1"><a href="#日期获取-1" class="headerlink" title="日期获取"></a>日期获取</h3><p>获取时间：<br><code>Date myDate = new Date();//获取系统当前时间</code><br><code>Date myDate = new Date(long Date)://根据给定的毫秒值创建日期对象</code><br><code>Date myDate = new Date(int year,int month,int date,int hour,int min,int sec)  //默认当前日期时间</code><br><code>Calendar now = Calendar.getInstance();//默认当前日历时间</code><br><code>now.set(date);//修改日历时间，传入一个date类型即可</code><br>获取时间戳：<br><code>long timestap=new Date().getTime();//日期类型获取时间戳</code><br><code>long timestap=Calendar.getInstance().getTime().getTime();//日期类型获取时间戳</code></p><h3 id="Calendar之now-get-参数-获取年月日参数"><a href="#Calendar之now-get-参数-获取年月日参数" class="headerlink" title="Calendar之now.get(参数):获取年月日参数"></a>Calendar之now.get(参数):获取年月日参数</h3><p><code>Calendar now = Calendar.getInstance();</code><br><code>now.set(参数)//参数为指定日期或者年月日时分秒;</code><br><code>Calendar.DAY_OF_MONTH：日期，和 Calendar.DATE 相同</code><br><code>Calendar.HOUR：12 小时制的小时数</code><br><code>Calendar.HOUR_OF_DAY：24小时制的小时数</code><br><code>Calendar.MINUTE：分钟</code><br><code>Calendar.SECOND：秒</code><br><code>Calendar.DAY_OF_WEEK：周几</code><br>获取指定时间(calender时间)数据：<br><code>int year = now.get(Calendar.YEAR); //2018，当前年份</code><br><code>int month = now.get(Calendar.MONTH) + 1; //12，当前月，注意加 1</code><br><code>int day = now.get(Calendar.DATE); //23，当前日</code><br>设定指定日期时间(calender时间)数据案例：<br><code>now.set(Calendar.YEAR, 2016); //设置单个字段</code><br><code>now.set(2016, 1, 1[, 11, 1, 1]);//设定年月日或者年月日时分或年月日时分秒</code><br><code>now.set(int year, int month, int date[, int hourOfDay, int minute, int second])</code><br><code>now.set(date); //直接传入一个 Date 类型的日期</code> </p><h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-ef1504ff2ace2b0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><h3 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h3><p>日期加减：<br><code>Calendar now = Calendar.getInstance();//获取当前时间</code><br><code>now.add(Calendar.YEAR, 1); //现在时间的1年后</code><br><code>now.add(Calendar.YEAR, -1); //现在时间的1年前</code><br>日期比较大小：<br><code>Date date1 = new Date();//获取时间date1</code><br><code>Date date2 = new Date();//获取时间date2</code><br><code>date1.before(date2);//true,当date1小于date2时，为true，否则为false</code><br><code>date2.after(date1);//true，当 date_02 大于 date_01 时，为 true，否则为 false</code><br><strong>date1.compareTo(date2);</strong><br><code>(1) 当 date1 小于 date2 时，为 -1;</code><br><code>(2) 当 date2 大于 date1 时，为 1;</code><br><code>(3) 当两个日期相等时，为 0;</code>   </p><h2 id="MySQL-时间日期操作"><a href="#MySQL-时间日期操作" class="headerlink" title="MySQL-时间日期操作"></a>MySQL-时间日期操作</h2><h3 id="获取日期和时间戳："><a href="#获取日期和时间戳：" class="headerlink" title="获取日期和时间戳："></a>获取日期和时间戳：</h3><p><code>now()：获取数据库当前时间，例如2008-08-08 22:28:21；</code><br><code>current_timestamp()：获取当前时间戳，例如2008-08-09 23:22:24；</code><br><code>timestamp(date)：日期转时间戳，例如timestamp(&#39;2008-08-08&#39;)-- 2008-08-08 00:00:00；</code><br><code>timestamp(dt,time)：timestamp(&#39;2008-08-08 08:00:00&#39;, &#39;01:01:01&#39;) -- 2008-08-08 09:01:01；</code><br><code>makdedate(year,dayofyear)：日期拼凑，makedate(2001,31); -- &#39;2001-01-31&#39;；makedate(2001,32); -- &#39;2001-02-01&#39;；</code><br><code>maketime(hour,minute,second)：时间拼凑，maketime(12,15,30); -- &#39;12:15:30&#39;</code>  </p><h3 id="日期格式化：-1"><a href="#日期格式化：-1" class="headerlink" title="日期格式化："></a>日期格式化：</h3><p><code>date_format(date,format)：date_format(&#39;2008-08-08 22:23:01&#39;, &#39;%Y%m%d%H%i%s&#39;)--20080808222301</code><br><code>str_to_date(str, format)：str_to_date(&#39;08/09/2008&#39;, &#39;%m/%d/%Y&#39;); -- 2008-08-09</code><br><code>str_to_date(&#39;08.09.2008 08:09:30&#39;, &#39;%m.%d.%Y %h:%i:%s&#39;); -- 2008-08-09 08:09:30</code><br><code>to_days(date)：日期转换为天，to_days(&#39;2008-08-08&#39;); -- 733627</code><br><code>time_to_sec(time)：时间转换为秒，time_to_sec(&#39;01:00:05&#39;); -- 3605</code><br><code>sec_to_time(seconds)：秒转换为时间，sec_to_time(3605); -- &#39;01:00:05&#39;</code>  </p><h3 id="时间计算："><a href="#时间计算：" class="headerlink" title="时间计算："></a>时间计算：</h3><p><code>set @dt = now();</code><br><code>select date_add(@dt, interval 1 day); -- add 1 day</code><br><code>select date_add(@dt, interval 1 hour); -- add 1 hour</code><br><code>select date_add(@dt, interval 1 minute); -- ...</code><br><code>select date_add(@dt, interval 1 second);</code><br><code>select date_add(@dt, interval 1 microsecond);</code><br><code>select date_add(@dt, interval 1 week);</code><br><code>select date_add(@dt, interval 1 month);</code><br><code>select date_add(@dt, interval 1 quarter);</code><br><code>select date_add(@dt, interval 1 year);</code>  </p><h3 id="时间加减："><a href="#时间加减：" class="headerlink" title="时间加减："></a>时间加减：</h3><p><code>datediff(date1,date2)：两个日期相减 date1 - date2，返回天数。datediff(&#39;2008-08-08&#39;, &#39;2008-08-01&#39;); -- 7</code><br><code>timediff(time1,time2)：两个日期相减 time1 - time2，返回 time 差值。timediff(&#39;2008-08-09 08:08:08&#39;, &#39;2008-08-08 00:00:00&#39;); -- 32:08:08</code>  </p><h3 id="比较时间大小：常规的-gt-、-lt-、-、-lt-gt-（不等于）、-gt-、-lt-等等！"><a href="#比较时间大小：常规的-gt-、-lt-、-、-lt-gt-（不等于）、-gt-、-lt-等等！" class="headerlink" title="比较时间大小：常规的&gt;、&lt;、=、&lt;&gt;（不等于）、&gt;=、&lt;=等等！"></a>比较时间大小：常规的&gt;、&lt;、=、&lt;&gt;（不等于）、&gt;=、&lt;=等等！</h3><p><code>例如：select * from tbl_xxx where &#39;2018-01-01 01：01：01&#39; &lt;= &#39;2018-02-02 02：02：02&#39;</code>  </p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   目前，因为公司开发使用的ssm框架，从前端js到后台java，以及mysql数据库，只要涉及到时间处理的问题，都难免会遇到日期获取、格式化、比较大小等操作，而且目前的博客都只针对单方面做了讲解，此文将决定做统一归纳汇总，以方便读者保存和分享。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>存储过程和存储函数</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/12/09/StoredRoutine/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/12/09/StoredRoutine/</id>
    <published>2017-12-09T15:52:20.000Z</published>
    <updated>2018-04-10T02:07:16.010Z</updated>
    
    <content type="html"><![CDATA[<p>   存储函数和存储过程统称为<strong>“存储例程”</strong>。<strong>“储存过程”</strong>是一个可编程的函数，它在数据库中创建并保存，数据库中的存储过程可以看做是对编程中面向对象方法的模拟。<strong>“存储函数”</strong>用户自定义函数是一种对MySQL扩展的途径，其用法与内置方法相同。存储过程和存储函数都是数据库端对数据库表操作的一种扩展，两者的区别：</p><ul><li><strong>总述</strong>：存储函数的针对性比较强，限制较多；存储过程的限制相对较少，但实现的功能会更复杂；</li><li><strong>参数的不同</strong>：（1）存储函数的参数类型类似于IN参数；（2）存储过程的参数类型有三种、IN参数、OUT参数、INOUT参数；</li><li><strong>返回值上不同</strong>：（1）存储函数将向调用者返回一个且仅返回一个结果值；（2）<br>存储过程将返回一个或多个结果集（函数做不到这一点），或者只是来实现某种效果或动作而无需返回值；</li><li><strong>调用方式不同</strong>：（1）存储函数嵌入在sql中使用的,可以在select中调用，就像内建函数一样，比如cos()、hex()；（2）存储过程只能通过call语句进行调用。</li></ul><a id="more"></a><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>01-定义存储过程名称和变量声明：“pr_add” 是个简单的 MySQL 存储过程，这个存储过程有两个 int 类型的输入参数 “a”、“b”，返回这两个参数的和。</p><blockquote><p><code>create procedure pr_add</code><br><code>(</code><br><code>in a int,</code><br><code>in b int</code><br><code>)</code></p></blockquote><p>02-书写过程逻辑</p><blockquote><p><code>begin</code>：开始sql逻辑<br><code>Sql逻辑语句</code> ：操纵数据的数据库的业务逻辑<br><code>end；</code>：结束sql逻辑  </p></blockquote><p>03-操作案例<br><img src="https://upload-images.jianshu.io/upload_images/9194313-e2caa5a88127803f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br><strong>调用：</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-3554be760dce4884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="07.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>MySQL 存储过程名字后面的“()”是必须的，即使没有一个参数，也需要“()” 。</li><li>MySQL 存储过程的参数不能指定默认值。</li><li>如果 MySQL 存储过程中包含多条 MySQL 语句，则需要 begin end 关键字。</li><li>MySQL 存储过程中的每条语句的末尾，都要加上分号 “;”。</li><li>不能在 MySQL 存储过程中使用 “return” 关键字。</li><li><code>call pr_add(10, null);</code>：“括号”必须有和“参数”必须填全。</li></ul><blockquote><p><code>Default默认值：DECLARE counter INT DEFAULT 0;</code><br><code>IF THEN、ELSEIF、ELSE、END IF：条件判断</code></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/9194313-3c518b45bf239f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><blockquote><p><code>LOOP、END LOOP：循环</code></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/9194313-b008adcc8067ab4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><blockquote><p><code>WHILE DO、END WHILE：循环</code></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/9194313-cde6316c45003aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"></p><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>存储函数的基本操作与存储过程基本类似，包括语法等，主要注意两者之间的区别即可：<br><img src="https://upload-images.jianshu.io/upload_images/9194313-2add792dc9ebbf56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"></p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p><img src="https://upload-images.jianshu.io/upload_images/9194313-66dc47b3aaf0c008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"></p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   存储函数和存储过程统称为&lt;strong&gt;“存储例程”&lt;/strong&gt;。&lt;strong&gt;“储存过程”&lt;/strong&gt;是一个可编程的函数，它在数据库中创建并保存，数据库中的存储过程可以看做是对编程中面向对象方法的模拟。&lt;strong&gt;“存储函数”&lt;/strong&gt;用户自定义函数是一种对MySQL扩展的途径，其用法与内置方法相同。存储过程和存储函数都是数据库端对数据库表操作的一种扩展，两者的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;总述&lt;/strong&gt;：存储函数的针对性比较强，限制较多；存储过程的限制相对较少，但实现的功能会更复杂；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数的不同&lt;/strong&gt;：（1）存储函数的参数类型类似于IN参数；（2）存储过程的参数类型有三种、IN参数、OUT参数、INOUT参数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值上不同&lt;/strong&gt;：（1）存储函数将向调用者返回一个且仅返回一个结果值；（2）&lt;br&gt;存储过程将返回一个或多个结果集（函数做不到这一点），或者只是来实现某种效果或动作而无需返回值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用方式不同&lt;/strong&gt;：（1）存储函数嵌入在sql中使用的,可以在select中调用，就像内建函数一样，比如cos()、hex()；（2）存储过程只能通过call语句进行调用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>EasyUI框架</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/12/07/EasyUI/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/12/07/EasyUI/</id>
    <published>2017-12-07T15:52:20.000Z</published>
    <updated>2018-04-07T13:50:55.372Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/QueryEasyUI/1733327?fr=aladdin" target="_blank" rel="external">EasyUI</a>是封装好的前端框架，使用EasyUI组件，能够轻松为开发者打造丰富而美观的UI界面，大大减少了前端页面展示的复杂性，使开发者不必为CSS样式及排版而苦恼，只需考虑数据的加载即可。<br><a id="more"></a></p><h2 id="EasyUI常用组件"><a href="#EasyUI常用组件" class="headerlink" title="EasyUI常用组件"></a>EasyUI常用组件</h2><p>   EasyUI的常用组件：Datagrid（数据网格）、Treegrid（树形网格）、Tabs（标签页/选项卡）、Layout（布局）、Messager（消息框）、Linkbutton（链接按钮）等，使用最多的还是Datagrid（数据网格），为大量数据的加载和分页做了非常大的贡献。下面主要抽取几点典型的组件进行讲解，新人上手都很快。</p><h3 id="Datagrid组件举例"><a href="#Datagrid组件举例" class="headerlink" title="Datagrid组件举例"></a>Datagrid组件举例</h3><p><strong>方式一</strong>：将属性直接写在data-options里面，url就是所要加载数据的路径（接口地址），field是返回的json数据变量与表格列对应的变量名。<br><img src="https://upload-images.jianshu.io/upload_images/9194313-44bd02e9e2f02ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br><strong>方式二</strong>：将属性与table分开，单独对属性进行操作。<br><img src="https://upload-images.jianshu.io/upload_images/9194313-b554252283efbdd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"><br><strong>每个组件都伴随着以下三大内容：属性、方法和事件</strong></p><ul><li><p><strong>常用属性</strong></p><blockquote><p><code>fitColumns</code>:单元格宽度随文字自适应；<br><code>url</code>：数据加载路径；<br><code>data</code>：可以写死也可以通过url去加载；<br><code>pagination</code>：是否开启分页；<br><code>rownumbers</code>：是否显示行号；<br><code>singleSelect</code>：是否只允许选中单条；<br><code>checkOnSelect</code>：是否选中行前的复选框，就选中整条数据；<br><code>selectOnCheck</code>：是否选中整条数据，复选框自动打勾；<br><code>rowStyler</code>：给哪些行设置样式；</p></blockquote></li><li><p><strong>常用方法</strong></p><blockquote><p><code>options</code>:返回（options）对象，就是data-options这个属性对象；<br><code>getData</code>：获取从后台接口所加载的数据；<br><code>getRowIndex</code>：获取指定选中行的索引；<br><code>getSelected</code>：获取选中行对象；</p></blockquote></li><li><p><strong>常用事件</strong></p><blockquote><p><code>onClickRow</code>:用户单机时触发；<br><code>onDblClickRow</code>：用户双击时触发；<br><code>onSelect</code>：选中一行时触发；<br><code>onUnselect</code>：取消一行选中时触发；</p></blockquote></li></ul><p>对以上属性、方法以及事件的操作方式基本都是：<code>$(&#39;#table的id&#39;).datagrid(属性/方法/事件)</code>可以参照下面的案例：<br><img src="https://upload-images.jianshu.io/upload_images/9194313-a49769a39e966f4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br>基本都是这个流程，熟悉了EasyUI的书写格式之后，使用API进行开发就相当容易了，对于英文的API由于有很多单词的意思无法正确理解，下面主要推荐是使用中文的API，想使用什么组件只需要进行搜索即可，基本都是直接套格式，一通百通。下面是中文API的链接，个人感觉还比较好用，分享给大家：<a href="http://www.jeasyui.net/plugins/183.html" target="_blank" rel="external">EasyUI中文API</a></p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/QueryEasyUI/1733327?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EasyUI&lt;/a&gt;是封装好的前端框架，使用EasyUI组件，能够轻松为开发者打造丰富而美观的UI界面，大大减少了前端页面展示的复杂性，使开发者不必为CSS样式及排版而苦恼，只需考虑数据的加载即可。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Quartz定时任务</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/12/06/Quartz/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/12/06/Quartz/</id>
    <published>2017-12-06T15:52:20.000Z</published>
    <updated>2018-04-06T13:49:47.333Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/quartz/3643055?fr=aladdin" target="_blank" rel="external">Quartz</a>是OpenSymphony开源组织在Job scheduling领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。Quartz定时主要分为三个基本要素：Scheduler（调度器）、Trigger（触发器）以及JobDetail &amp; Job（任务）<br><a id="more"></a></p><h2 id="Quartz三大基本要素解读"><a href="#Quartz三大基本要素解读" class="headerlink" title="Quartz三大基本要素解读"></a>Quartz三大基本要素解读</h2><p>关于Quartz的使用大致有两种：</p><ul><li>一种是通过注解的方式使用，但是这种方式的局限性很明显，只能通过的注解的方式写死<strong>Cron表达式</strong>，运行过程中去修改会相当麻烦；</li><li>另一种就是使用最传统的方式，Scheduler+Trigger+JobDetail &amp; Job按步骤一步步实现，这种方式可以通过获取bean的方式去操作dao层，实现<strong>前台手动设置时间并随意更改时间</strong>的目的。</li></ul><h3 id="注解定时"><a href="#注解定时" class="headerlink" title="注解定时"></a>注解定时</h3><p><strong>实体类</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-a0a3a85048380aa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>applicationContext.xml配置</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-7a12c5acac6256e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="手动定时"><a href="#手动定时" class="headerlink" title="手动定时"></a>手动定时</h3><p><strong>定义Job类</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-ea72ef93b0b138f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>定义JobDetail和Trigger</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-fd3b5c59383de055.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>绑定JobDetail和Trigger并开启定时任务</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-3812f9fd0d76847b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="Scheduler（调度器）"><a href="#Scheduler（调度器）" class="headerlink" title="Scheduler（调度器）"></a>Scheduler（调度器）</h3><p>作用：调度器，所有的任务调度都是有他控制（包括任务的开始和结束）；</p><h3 id="Trigger（触发器"><a href="#Trigger（触发器" class="headerlink" title="Trigger（触发器"></a>Trigger（触发器</h3><p>作用：触发器，定义任务被触发的时间，是哪个时间点被触发，触发的频次是多少，这些都是通过调度器进行设置的；</p><h3 id="JobDetail-amp-Job（任务）"><a href="#JobDetail-amp-Job（任务）" class="headerlink" title="JobDetail &amp; Job（任务）"></a>JobDetail &amp; Job（任务）</h3><p>作用：JobDetail定义任务的数据（外部需要传入job中的一些参数），而<br>Job（任务）是个接口，所有定时任务的业务逻辑都写在实现了这个接口的类里面。sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/quartz/3643055?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Quartz&lt;/a&gt;是OpenSymphony开源组织在Job scheduling领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。Quartz定时主要分为三个基本要素：Scheduler（调度器）、Trigger（触发器）以及JobDetail &amp;amp; Job（任务）&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java之设计模式</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/12/05/DesignPatterns/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/12/05/DesignPatterns/</id>
    <published>2017-12-05T12:15:00.000Z</published>
    <updated>2018-04-09T13:59:33.002Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/java/85979?fr=aladdin&amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;fromid=4148931" target="_blank" rel="external">Java</a>中的设计模式有很多种，初级接触的到的有以下几种：单例模式、工厂模式、适配器模式和装饰模式等。下面主要对以上四种模式进行简单讲解：</p><a id="more"></a><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>作用：保证在整个程序的声明周期中，一个类在内存中只有一个对象。单例模式分为两种：饿汉式单例和懒汉式单例。单例模式：将构造私有化，防止自身被实例化。</p><blockquote><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><p>解读：在类加载时，不管用不用到这个类的对象，程序在加载该类时都会为之创建一个对象。标准模型：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-92200e0d6276f5d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><p>解读：在类加载时，先声明类的静态成员，并赋予空值。在程序运行过程中，创建此类的对象前先判断此类的对象是否为空，如果为空就New,否者就不创建新的对象。标准模型：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-8d820f35fb39a96e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p></blockquote><p>注意事项：（1）构造方法和成员变量都是private，只有一个public方法；（2）成员和方法都是static类型，在内存中只维护一份。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>作用：为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，替代“new操作”，达到提高灵活性的目的。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-81fa7feb77250313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><h2 id="建造（Builder）模式"><a href="#建造（Builder）模式" class="headerlink" title="建造（Builder）模式"></a>建造（Builder）模式</h2><p>作用：是一种对象构建的设计模式，它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。举例：组装一辆车，需要车轮、方向盘、底座等等，写一个公共的接口（并附上实现类），提供这些散件的具体组装方式，以及整车最终完成的组装方法，通过对不同方法的调用来实现不同的组装步骤。<br><img src="https://upload-images.jianshu.io/upload_images/9194313-c02f40ae408372ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM图片20180404104510.png"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>作用：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。观察者模式又叫发布-订阅(Publish/Subscribe)模式。例如：老师有电话号码，学生需要知道老师的电话号码以便于在合适的时候拨打，在这样的组合中，老师就是一个被观察者（Subject），学生就是需要知道信息的观察者，当老师的电话号码发生改变时，学生得到通知，并更新相应的电话记录。<br><strong>被观察者：</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-096b28828a92b75d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>观察者</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-0641550b6ae7503f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>测试</strong><br><img src="https://upload-images.jianshu.io/upload_images/9194313-39a81ba6c2e3cdd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>作用：把一个类的接口转换成客户端所期望的另一种接口，从而使原本因为接口不匹配而无法一起工作的两个类能够一起工作。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-73ed414772751403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"><br>简单说明：我们都知道，实现一个接口就需要实现接口里面的所有方法，否则只实现部分方法那就不叫“实现”了。那么如果想达到实现接口中部分方法的目的，就需要用到这种适配器模式。具体操作：抽象类实现接口中所有方法，目标类继承此抽象类，重写部分所需方法。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>作用：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。关于装饰者模式的解读，有篇文章确实写的非常不错，看了很多文章，就这篇还可以，很简明。装饰者模式，有点类似于aop编程。<br>装饰者模式博客链接：<a href="http://www.cnblogs.com/chenssy/archive/2013/05/23/3094138.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/archive/2013/05/23/3094138.html</a></p><p>More info: <a href="http://www.javait.club/2017/07/23/FunctionChange/" target="_blank" rel="external">方法“重载”和“重写”</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/java/85979?fr=aladdin&amp;amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;amp;fromid=4148931&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;中的设计模式有很多种，初级接触的到的有以下几种：单例模式、工厂模式、适配器模式和装饰模式等。下面主要对以上四种模式进行简单讲解：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybais三剑客</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/12/04/MybatisThreeTools/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/12/04/MybatisThreeTools/</id>
    <published>2017-12-04T07:23:28.000Z</published>
    <updated>2017-12-14T08:12:27.409Z</updated>
    
    <content type="html"><![CDATA[<p>   最近一直在学习新技术，寻找比较好的开发资源。无意间发现了下面这三个东西，再开发中，不得不说，确实非常实用，确实无可挑剔。另外，推荐更多开发者可以从eclipse转往idea开发了，idea的智能提示和各方面的插件和性能，都能大幅度提高开发的效率。下面主要介绍下mybatis三剑客：mybatis-generator(逆向工程生成dao,xml,pojo)/mybatis-plugin插件(在Mapper接口方法上和Mapper.xml对应sql语句处切换)/mybatis-pagehelper(分页插件)<br><a id="more"></a></p><h2 id="mybatis-generator"><a href="#mybatis-generator" class="headerlink" title="mybatis-generator"></a>mybatis-generator</h2><h3 id="mybatis-generator使用的准备工作"><a href="#mybatis-generator使用的准备工作" class="headerlink" title="mybatis-generator使用的准备工作"></a>mybatis-generator使用的准备工作</h3><p>（1）在pom文件中添加，插件；<br><img src="http://upload-images.jianshu.io/upload_images/9194313-cfeef82b983339a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br>（2）在resources目录下添加以下配置文件：generatorConfig.xml和datasource.properties。<br><strong>generatorConfig.xml：</strong>是mybatis-generator的核心配置文件，用来通过数据库表，逆向生成dao,xml,pojo内的文件，所以这个配置文件要配置的内容大致有以下几个板块：数据库连接、文件生成路径指定、指定数据库对应表名。<br><strong>datasource.properties：</strong>配置数据源连接的信息<br><img src="http://upload-images.jianshu.io/upload_images/9194313-db608e4553b3367f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><h3 id="mybatis-generator生成逆向工程"><a href="#mybatis-generator生成逆向工程" class="headerlink" title="mybatis-generator生成逆向工程"></a>mybatis-generator生成逆向工程</h3><p>按图步骤进行逆向工程的生成，等待一会就会发现，dao,xml,pojo这三个目录下已经有了文件。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-0962c4408c461c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><h2 id="mybatis-plugin插件"><a href="#mybatis-plugin插件" class="headerlink" title="mybatis-plugin插件"></a>mybatis-plugin插件</h2><p>在Mapper接口方法上和Mapper.xml对应sql语句处切换。该插件的安装具体可参考如下链接：<a href="http://blog.csdn.net/pansanday/article/details/54892990。安装成功后破解的话，按照以下链接去提示去破解，替换一个jar包就可以了：https://www.awei.org/2017/11/08/idea-mybatis-plugin-3-21-po-jie-fang-fa/" target="_blank" rel="external">http://blog.csdn.net/pansanday/article/details/54892990。安装成功后破解的话，按照以下链接去提示去破解，替换一个jar包就可以了：https://www.awei.org/2017/11/08/idea-mybatis-plugin-3-21-po-jie-fang-fa/</a><br><strong>注意：</strong>直接下载破解所需要的Jar就可以了。<br>成功后的效果图：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-be1da525878dd2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"></p><h2 id="mybatis-pagehelper-分页插件"><a href="#mybatis-pagehelper-分页插件" class="headerlink" title="mybatis-pagehelper(分页插件)"></a>mybatis-pagehelper(分页插件)</h2><h3 id="添加jar"><a href="#添加jar" class="headerlink" title="添加jar"></a>添加jar</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-8583c84fd4f2c511.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"></p><h3 id="配置bean"><a href="#配置bean" class="headerlink" title="配置bean"></a>配置bean</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-8a34eb4a3ba2786a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"></p><h3 id="使用分页"><a href="#使用分页" class="headerlink" title="使用分页"></a>使用分页</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-697f3fe32058b442.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="07.png"></p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   最近一直在学习新技术，寻找比较好的开发资源。无意间发现了下面这三个东西，再开发中，不得不说，确实非常实用，确实无可挑剔。另外，推荐更多开发者可以从eclipse转往idea开发了，idea的智能提示和各方面的插件和性能，都能大幅度提高开发的效率。下面主要介绍下mybatis三剑客：mybatis-generator(逆向工程生成dao,xml,pojo)/mybatis-plugin插件(在Mapper接口方法上和Mapper.xml对应sql语句处切换)/mybatis-pagehelper(分页插件)&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot初级</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/12/03/SpringBoot/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/12/03/SpringBoot/</id>
    <published>2017-12-03T11:45:27.000Z</published>
    <updated>2017-12-05T14:44:16.387Z</updated>
    
    <content type="html"><![CDATA[<p>  <a href="https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin" target="_blank" rel="external">Spring Boot</a>是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。<br><a id="more"></a></p><h2 id="SpringBoot特点"><a href="#SpringBoot特点" class="headerlink" title="SpringBoot特点"></a>SpringBoot特点</h2><ul><li>创建独立的Spring应用程序</li><li>嵌入的Tomcat，无需部署WAR文件</li><li>简化Maven配置</li><li>自动配置Spring</li><li>提供生产就绪型功能，如指标，健康检查和外部配置</li><li>绝对没有代码生成和对XML没有要求配置</li></ul><h2 id="SrpingBoot环境配置"><a href="#SrpingBoot环境配置" class="headerlink" title="SrpingBoot环境配置"></a>SrpingBoot环境配置</h2><p>关于SpringBoot环境配置的文章很多，再此就不再做讲解，可以参看以下文章链接：<br><code>https://www.cnblogs.com/woshimrf/p/5602051.html</code></p><h2 id="SrpingBoot开发项目"><a href="#SrpingBoot开发项目" class="headerlink" title="SrpingBoot开发项目"></a>SrpingBoot开发项目</h2><h3 id="配置文件application-yml解读"><a href="#配置文件application-yml解读" class="headerlink" title="配置文件application.yml解读"></a>配置文件application.yml解读</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-4fe581f75d76b320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><ul><li><strong>分环境配置：</strong>如果项目的配置环境需要分“开发环境”和“生产环境”两种，那么就要分别进行配置。在application.yml所在目录下，新建开发环境（application-dev.yml）和生产环境（application-prod.yml）两种配置文件，然后在application.yml进行引用。如下：<br><code>active:dev---表示启用dev开发者模式下的配置文件</code></li></ul><ul><li><p><strong>@Value注解：</strong>用来获取配置文件中指定属性名的值，并将属性赋予到变量中来。<br><code>案例：@Value（&quot;${name}&quot;）private String name;</code></p></li><li><p><strong>配置映射JavaBean：</strong>将配置文件中属性封装到JavaBean属性中,使用@ConfigurationProperties进行配置。<br><code>@ConfigurationProperties(prefix=&quot;girl&quot;)加载类上，自动对齐属性进行映射</code><br><em>注意：</em>此处映射完成，只是将配置文件girl开头的属性映射到了JavaBean，如果通过@Autowired使用此JavaBean需进行@Component注解声明。</p></li><li><p>关于jpa的配置<strong>ddl-auto:</strong>可选值有很多，下面只对经常使用的两个做简单介绍:<br>(1)create：每次启动服务，都重新建表，原表数据全部删除；<br>(2)update：第一次启动，同样会创建表结构，如果表中有数据，数据保留；<br>(3)show-sql:设置为true。</p></li></ul><h3 id="SpringBoot中使用JPA"><a href="#SpringBoot中使用JPA" class="headerlink" title="SpringBoot中使用JPA"></a>SpringBoot中使用JPA</h3><p>Spring Data JPA 框架，主要针对的就是 Spring 唯一没有简化到的业务逻辑代码，至此，开发者连仅剩的实现持久层业务逻辑的工作都省了，唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！可以简单理解为，JPA就是用来简化dao层的，JPA对增删改查操作的方法都进行了封装，开发者只需继承JpaRespository接口便可调用内置的一些方法。<br><code>public interface MyRepository extends JpaRepository&lt;Girl,Integer&gt;</code><br>说明：<strong>JpaRepository<girl,integer></girl,integer></strong>，默认通过主键操作Girl类所映射的表，当然也可以自定义方法对其进行操作。<br>（1）使用JPA配置JavaBean映射表的字段：<br> 新建javabean,类上加注解@Entity，将数据库表的字段与javabean进行映射，注意，必须在类中声明一个无参的构造函数，否者系统会报错，如果有主键，在逐渐属性上通过注解进行定义，@Id和@GeneratedValue<br>（2）<strong>“常用方法”</strong></p><ul><li>查所有，findAll()返回List集合。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-c369fec2d21b23d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"><br><code>添加：girlRepository.save(girl)</code><br><code>查一个：girlRepository.findOne(id)</code><br><code>更新：girlRepository.save(girl)</code><br><code>删除：girlRepository.delete(Integer age)</code></li><li>自定查询方法：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-0c1bbe8ec6093d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br><img src="http://upload-images.jianshu.io/upload_images/9194313-c7efbda75074bdca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></li></ul><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>@RequestMapping请求路径映射<br><code>映射多个：@RequestMapping（value={&quot;/hello&quot;,&quot;/hi&quot;}）</code></li><li>@PathVariable（）路径参数映射(配合使用)<br><code>@RequestMapping(value=&quot;/say/{id}&quot;)</code><br><code>@PathVariable（“id”） Integer id</code></li><li>@RequestParam（）路径参数映射<br><code>@RequestParam（value=“id”,required=false,defaultValue=&quot;0&quot;）Integer id</code></li><li>@Get/@PostMapping:Get/post请求+RequestMapping</li></ul><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;a href=&quot;https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Boot&lt;/a&gt;是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>“返回值”线程</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/30/CreateTask/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/30/CreateTask/</id>
    <published>2017-11-30T09:43:11.000Z</published>
    <updated>2017-12-02T10:24:19.166Z</updated>
    
    <content type="html"><![CDATA[<p>   线程任务有以下几种情况，一种是可以是实现了Runnable接口，重写了run方法的<strong>“无返回值”</strong>的任务；一种是可以使实现了Callable接口，可以<strong>“有返回值”</strong>的任务。下面主要针对有返回值的这种情况做案例说明。<br><a id="more"></a></p><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable<v>接口</v></h2><p>该接口声明了一个名称为call()的方法，同时这个方法可以有返回值V，也可以抛出异常。使用Callable+Future获取执行结果，案例抽取：<br>（1）编写Callable实现类<br><code>1:public class CallableDemo implements Callable&lt;Integer&gt;</code><br><code>2:...public Integer call() throws Exception ...</code><br>（2）编写测试类CallableTest<br><code>3:public class CallableTest</code><br><code>4:ExecutorService es = Executors.newSingleThreadExecutor();  //创建线程池</code><br><code>5:CallableDemo calTask=new CallableDemo();//创建Callable对象任务</code><br><code>6:Future&lt;Integer&gt; future =es.submit(calTask);//提交任务并获取执行结果</code><br><code>7:future.get()//输出返回来的值</code><br>注意：excute方法不能执行Callable任务，submit支持Callable任务和Runnable任务。</p><h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future<v>接口</v></h2><p>Future<v>接口是用来获取异步计算结果的，说白了就是对具体的Runnable或者Callable对象任务执行的结果进行获取(get()),取消(cancel()),判断是否完成等操作。<br><code>V get() ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</code></v></p><h2 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h2><p>使用Callable+FutureTask获取执行结果，案例抽取：<br><code>1:public class CallableDemo implements Callable&lt;Integer&gt;</code><br><code>2:...public Integer call() throws Exception ...</code><br>（2）编写测试类CallableTest<br><code>3:public class CallableTest</code><br><code>4:ExecutorService es = Executors.newSingleThreadExecutor();  //创建线程池</code><br><code>5:CallableDemo T=new CallableDemo();//创建Callable对象任务</code><br><code>6:FutureTask&lt;Integer&gt; futureTask=new FutureTask&lt;&gt;(T);//创建FutureTask</code><br><code>7:FutureTask&lt;Integer&gt; futureTask=new FutureTask&lt;&gt;(T);//提交任务并获取执行结果</code><br><code>8:future.get()//输出返回来的值</code><br>注意：线程池用完后，一定要关闭，es.shutdown();  </p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   线程任务有以下几种情况，一种是可以是实现了Runnable接口，重写了run方法的&lt;strong&gt;“无返回值”&lt;/strong&gt;的任务；一种是可以使实现了Callable接口，可以&lt;strong&gt;“有返回值”&lt;/strong&gt;的任务。下面主要针对有返回值的这种情况做案例说明。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈常用“线程池”</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/29/ThreadPool/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/29/ThreadPool/</id>
    <published>2017-11-29T08:12:35.000Z</published>
    <updated>2017-12-02T09:25:51.014Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661?fr=aladdin" target="_blank" rel="external">线程池</a>是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/9194313-4103d915cafd78b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.jpg"><br><strong>线程池接口：</strong></p><ul><li>Executor：它是”执行者”接口，它是来执行任务的。准确的说，Executor提供了execute()接口来执行已提交的 Runnable 任务的对象。Executor存在的目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。</li><li>ExecutorService：ExecutorService继承于Executor。它是”执行者服务”接口，它是为”执行者接口Executor”服务而存在的；准确的话，ExecutorService提供了”将任务提交给执行者的接口(submit方法)”，”让执行者执行任务(invokeAll, invokeAny方法)”的接口等等。</li></ul><p><strong>线程池类：</strong></p><ul><li>ThreadPoolExecutor就是大名鼎鼎的”线程池”。ThreadPoolExecutor是线程池类。对于线程池，可以通俗的将它理解为”存放一定数量线程的一个线程集合。线程池允许若个线程同时允许，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。”</li></ul><h2 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h2><h3 id="newFixedThreadPool-6"><a href="#newFixedThreadPool-6" class="headerlink" title="newFixedThreadPool(6)"></a>newFixedThreadPool(6)</h3><p><code>案例：ExecutorService service = Executors.newFixedThreadPool(6);</code></p><blockquote><p>创建一个6个线程的线程池，每来一个任务，就创建一个线程，当6个线程都启动且在运行时，来了第七个任务，该任务就进入等待区排队。线程起来后，永远不会消失。</p></blockquote><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h3><p><code>案例：ExecutorService service = Executors.newCachedThreadPool();</code></p><blockquote><p>刚开始一个线程都没有，来一个任务就起一个线程，当来新任务时发现有空闲的线程，就直接使用空闲的，不再新起线程了（线程空闲1min就自动销毁）；当来新任务时发现没有空闲的线程，此时便启动一个新的线程，保证在等待区任务队列中的任务个数永远为0；</p></blockquote><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h3><p><code>案例：ExecutorService service = Executors.newSingleThreadExecutor();</code></p><blockquote><p>线程池永远只有一个线程。保证任务的先后执行顺序，只有第一个任务执行完，才能执行第二个任务。线程起来后永远不结束。</p></blockquote><h3 id="newScheduledThreadPool-4"><a href="#newScheduledThreadPool-4" class="headerlink" title="newScheduledThreadPool(4);"></a>newScheduledThreadPool(4);</h3><p><code>案例：ScheduledExecutorService service = Executors.newScheduledThreadPool(4);</code></p><blockquote><p>执行定时的任务。线程是可以复用的，第一个线程来了，执行完后，来第二个线程，这时候就直接用已存在的空闲线程。定时容器装任务，线程启动后就不会销毁。service.scheduleAtFixedRate(task, 0, 500, TimeUnit.MILLISECONDS);第一个tast立即执行，没隔500mms执行一次任务。</p></blockquote><h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool();"></a>newWorkStealingPool();</h3><p><code>案例：ExecutorService service = Executors.newWorkStealingPool();</code></p><blockquote><p>工作窃取，每个线程维护自己的等待队列，当自己队列为空时，会去偷其他线程队列中的任务。</p></blockquote><h3 id="new-ForkJoinPool"><a href="#new-ForkJoinPool" class="headerlink" title="new ForkJoinPool()"></a>new ForkJoinPool()</h3><p>作用：将一个任务进行拆分处理，并将处理后的结果进行汇总。<br><code>案例：ForkJoinPool fjp = new ForkJoinPool();</code><br>执行分块的类，需要extends RecursiveTask<long>或RecursiveAction，其中：AddTask extends RecursiveAction：无返回值；AddTask extends RecursiveTask<long> ：有返回值，通过task.join()加入主线程汇总求和。<br><code>分块：AddTask task = new AddTask(0, nums.length);</code><br><code>执行分块计算：fjp.execute(task);</code></long></long></p><p>案例示范：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-3349472a4be33852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;线程池&lt;/a&gt;是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并发集合类</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/27/ConcurrencyClass/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/27/ConcurrencyClass/</id>
    <published>2017-11-27T15:52:20.000Z</published>
    <updated>2017-12-02T07:49:39.796Z</updated>
    
    <content type="html"><![CDATA[<p>   本文主要针对并发的集合类进行一个简单的内容讲解，让读者能够一目了然，如果需要具体了解底层的原理，可以参看网上一些比较好的解读文章，从底层了解这些支持并发的集合类。在之前学习的集合类中，Vector和HashTable都是线程安全的，下面就开始支持并发的集合类。<br><a id="more"></a></p><h2 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote><p>(1)-<strong>ConcurrentHashMap</strong>是线程安全的哈希表。HashMap是非线程安全的哈希表，常用于单线程程序中；Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的；Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。<br>(2)-<strong>ConcurrentHashMap</strong>是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。</p></blockquote><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的时，它具有以下特性：</p><blockquote><p>(1)-它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。<br>(2)-它是线程安全的。<br>(3)-因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大<br>(4)-迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作。<br>(5)-使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p></blockquote><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><blockquote><p>它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表(HashMap)”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。<br>ConcurrentSkipListMap:</p></blockquote><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><blockquote><p>ConcurrentSkipListMap是线程安全的有序的哈希表，适用于高并发的场景。ConcurrentSkipListMap和TreeMap，它们虽然都是有序的哈希表。但是，第一，它们的线程安全机制不同，TreeMap是非线程安全的，而ConcurrentSkipListMap是线程安全的。第二，ConcurrentSkipListMap是通过跳表实现的，而TreeMap是通过红黑树实现的。关于跳表(Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。</p></blockquote><h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><blockquote><p>(1)–ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。<br>(2)–ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。</p></blockquote><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><blockquote><p>(1)–ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。<br>线程安全是指，ArrayBlockingQueue内部通过“互斥锁”保护竞争资源，实现了多线程对竞争资源的互斥访问。而有界，则是指ArrayBlockingQueue对应的数组是有界限的。 阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待；而且，ArrayBlockingQueue是按 FIFO（先进先出）原则对元素进行排序，元素都是从尾部插入到队列，从头部开始返回。<br>(2)–注意：ArrayBlockingQueue不同于ConcurrentLinkedQueue，ArrayBlockingQueue是数组实现的，并且是有界限的；而ConcurrentLinkedQueue是链表实现的，是无界限的。</p></blockquote><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><blockquote><p>(1)–LinkedBlockingQueue是一个单向链表实现的阻塞队列。该队列按 FIFO（先进先出）排序元素，新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。<br>(2)–此外，LinkedBlockingQueue还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE。</p></blockquote><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><blockquote><p>(1)–LinkedBlockingDeque是双向链表实现的双向并发阻塞队列。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)；并且，该阻塞队列是支持线程安全。<br>(2)–此外，LinkedBlockingDeque还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE。</p></blockquote><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><blockquote><p>ConcurrentLinkedQueue是线程安全的队列，它适用于“高并发”的场景。<br>它是一个基于链接节点的无界线程安全队列，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置null元素（内部实现的特殊节点除外）。</p></blockquote><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   本文主要针对并发的集合类进行一个简单的内容讲解，让读者能够一目了然，如果需要具体了解底层的原理，可以参看网上一些比较好的解读文章，从底层了解这些支持并发的集合类。在之前学习的集合类中，Vector和HashTable都是线程安全的，下面就开始支持并发的集合类。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CountDownLatch浅析</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/22/CountDownLatch/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/22/CountDownLatch/</id>
    <published>2017-11-22T15:52:20.000Z</published>
    <updated>2017-12-02T06:42:11.957Z</updated>
    
    <content type="html"><![CDATA[<p>   一个案例，轻松掌握CountDownLatch（门闩）用法。CountDownLatch是一个同步辅助类，是通过“共享锁”实现的。在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。下面只需通过下面这个案例，就可以基本了解CountDownLatch的用途和用法了。<br><a id="more"></a></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="http://upload-images.jianshu.io/upload_images/9194313-ca5391daa2300c55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br>案例中使用到了CountDownLatch的三个常用方法，从案例中抽取CountDownLatch的三个常用方法进行解读。</p><h3 id="new-CountDownLatch-int-count"><a href="#new-CountDownLatch-int-count" class="headerlink" title="new CountDownLatch(int count)"></a>new CountDownLatch(int count)</h3><p><code>CountDownLatch menShuan = new CountDownLatch(5);</code><br>创建一个门闩，并初始化门闩计数器的数字为5,在CountDownLatch中，计数器是不可以被重置的，计数器的作用就是当count减到0时，唤醒使用menShuan.await（）正在等待中的线程。</p><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h3><p><code>menShuan.countDown()：调用一次countDown()，门闩计数器减1</code><br>递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</p><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p><code>menShuan.await()：主线程等待门闩计数器减至0时，获取共享锁</code><br>使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   一个案例，轻松掌握CountDownLatch（门闩）用法。CountDownLatch是一个同步辅助类，是通过“共享锁”实现的。在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。下面只需通过下面这个案例，就可以基本了解CountDownLatch的用途和用法了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生产者和消费者</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/20/ProducerAndConsumer/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/20/ProducerAndConsumer/</id>
    <published>2017-11-20T11:03:35.000Z</published>
    <updated>2017-11-30T14:03:21.189Z</updated>
    
    <content type="html"><![CDATA[<p>多线程中的生产者和消费者案例，非常具有研究性，也值得考究。这就好比理科生解高数一样，越推理越有激情，而无法自拔。下面介绍一下比较易懂的一个生产者和消费者案例：写一个固定容量同步容器，拥有put和get方法，能够支持3个生产者线程以及10个消费者线程的阻塞调用。</p><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><h3 id="案例内容分析："><a href="#案例内容分析：" class="headerlink" title="案例内容分析："></a>案例内容分析：</h3><ul><li><p>需要一个同步容器，可以往里添加元素，也可以往外拿元素；<br><strong>解读1：</strong>需要一个容器，我们只对其进行添加和删除操作，从所学知识list和Map中，我们选择了LinckedList,因为LinckedList底层采用是双链表结构，而链表的结构相对ArraryList就是增删效率高，ArraryList由于底层使用的是数组，可以通过角标进行查询，所以选择了LinckedList。而且LinckedList在删除时会返回锁删除的元素值。<br><strong>解读2：</strong>容器是同步的，所以在增删的过程中，是不能被打扰的，即在增的时候，别人不能删和增。所以，这两个方法都应该上锁，且锁对象是这个容器。所有，我们到这里，大致可以模拟出这个容器的框架了：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-6117d277dba7378b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p></li><li><p>能够支持3个生产者线程以及10个消费者线程的阻塞调用<br><strong>解读：</strong>创建三个线程，去调用生产方法（put方法）；创建10个线程，去掉用消费方法（get方法）。用上for循环即可。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-6efb66c08d53fd73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p></li></ul><h3 id="细节解读"><a href="#细节解读" class="headerlink" title="细节解读"></a>细节解读</h3><p><code>1）for(int i=0;i&lt;10;i++){new Thread(new Runnable(){...}）.start（）}</code></p><blockquote><p>创建了十个线程用来执行new Runnable()实例的run方法，因为循环了10次，所以每个new Runnable()实例是不一样的。10个线程执行run()方法在不考虑run()里面的代码情况下，是互不影响的，因为有每个线程对应一个新的new Runnable()实例。所以，可能线程1在执行run方法的时候，线程2也在执行run方法。</p></blockquote><p><code>2）sync.put(manTou);</code></p><blockquote><p>不管是生产者还是消费者，线程的run（）方法里，都需要的是同一个锁对象，这时候问题就来了，13个线程开始出现了关联。即使两个线程同时执行了run()但是没有锁，也无法继续往下。线程1执行完了，释放了锁，线程2才能获得锁执行run()方法里面的代码。</p></blockquote><p><code>3)...run() {for(...){sync.put(manTou);}}</code>        `</p><blockquote><p>run()内面的for是可以抽象理解为是能够被其他线程“打断”的，这里的打断只得是该线程循环一次后，执行完了一次sync.put(manTou);}，释放了锁，这时锁被第二个线程拿到了，那么再进行第二次循环时，该线程只能等到另外的线程释放锁了再执行。</p></blockquote><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多线程中的生产者和消费者案例，非常具有研究性，也值得考究。这就好比理科生解高数一样，越推理越有激情，而无法自拔。下面介绍一下比较易懂的一个生产者和消费者案例：写一个固定容量同步容器，拥有put和get方法，能够支持3个生产者线程以及10个消费者线程的阻塞调用。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>守护线程（Daemon）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/19/Daemon/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/19/Daemon/</id>
    <published>2017-11-19T11:03:35.000Z</published>
    <updated>2017-11-29T11:20:01.705Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护线程-又称后台线程，英文：Daemon"><a href="#守护线程-又称后台线程，英文：Daemon" class="headerlink" title="守护线程(又称后台线程，英文：Daemon)"></a>守护线程(又称后台线程，英文：Daemon)</h3><blockquote><p>是指在程序运行的时候，在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。<strong>因此，当所有非后台线程执行结束后，程序也将终止。</strong><br>同时会杀死所有后台线程，<strong>反过来，只要有任何非后台线程还在运行，程序就不会终止。</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-abe812f11db8570f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br><img src="http://upload-images.jianshu.io/upload_images/9194313-13e93d91743c3136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><ul><li>如果是后台线程，程序马上终止。</li><li>如果不是后台线程，主线程main()将等待5s，即子线程结束时，结束。</li><li>例如：t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;守护线程-又称后台线程，英文：Daemon&quot;&gt;&lt;a href=&quot;#守护线程-又称后台线程，英文：Daemon&quot; class=&quot;headerlink&quot; title=&quot;守护线程(又称后台线程，英文：Daemon)&quot;&gt;&lt;/a&gt;守护线程(又称后台线程，英文：Daemon)
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>volatile和synchronized</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/18/volatile_synchronized/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/18/volatile_synchronized/</id>
    <published>2017-11-18T15:52:20.000Z</published>
    <updated>2017-12-02T07:43:02.364Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin" target="_blank" rel="external">多线程</a>中最容易混淆和最值得考究的一个问题，就是研究volatile和synchronized的区别，这两个关键字主要用在两个线程共享同一个对象的情况，当对象的属性值更改后，对线程内用到该属性参数的影响。<br><a id="more"></a><br>  一般情况下，两个线程虽然共享了同一个对象，在new Thread（obj）的时候，obj对象的属性i就会从主内存中拷贝到线程的工作内存中，两个线程拷贝同样的初始值i；启动两线程，当有线程1对i进行了修改，线程2是不知道的，依旧使用自身工作内存中的i，而此时主内存中的值已经是修改后的值。这就涉及到JMM内存模型：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-b59fb934a80f06c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h3 id="原子性和可见性"><a href="#原子性和可见性" class="headerlink" title="原子性和可见性"></a>原子性和可见性</h3><ul><li><strong>可见性：</strong>一个线程对共享变量进行修改，修改后能及时的被其他线程看到。</li><li><strong>原子性：</strong>即不可再分了，不能分为多步操作。比如赋值或者return。比如”a = 1;”和 “return a;”这样的操作都具有原子性。类似”a += b”这样的操作不具有原子性，在某些JVM中”a += b”可能要经过这样三个步骤：①　取出a和b；②　计算a+b；③　将计算结果写入内存。</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-81d6a3f9e82f317c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><blockquote><p>volatile关键字，保证了可见性，即线程1对变量进行了修改，他能保证线程2在读取这个变量时，读取到的都是最新值。但volatile不具备原子性，对i++此类不具备原子性的运算操作，如果线程2先读取了i值，但是还未进行计算，此时由于i++不具备原子性，线程2被线程1打断，线程1修改了i值，此时虽然内存中都更新到了最新值，但是线程2由于已经读取过了，不会回头再去检查读取的是否为最新的，而是继续执行下面代码，于是线程2的结果只是覆盖了缓存中的值。</p></blockquote><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>synchronized保证代码具有原子性和可见性，可见性保证每次读取到的是最新值，原子性保证在整个操作过程中确保代码执行的原子性，不可分割。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-5a3c1a82d860b68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br>以上代码synchronized部分，保证每次读取i时，读的都是最新值，且在i++问题上不会被打断，执行完之后若又存在修改，再次读取时将又是最新的i值。synchronized保证了，修改i值操作要么在读取i之前，要么在i写回内存后。</p><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ul><li>1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</li><li>2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</li><li>3）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.</li><li>4）volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</li></ul><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多线程&lt;/a&gt;中最容易混淆和最值得考究的一个问题，就是研究volatile和synchronized的区别，这两个关键字主要用在两个线程共享同一个对象的情况，当对象的属性值更改后，对线程内用到该属性参数的影响。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/18/ReentrantLock/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/18/ReentrantLock/</id>
    <published>2017-11-18T15:52:20.000Z</published>
    <updated>2017-11-29T15:01:44.446Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin" target="_blank" rel="external">ReentrantLock</a>是一个可重入的互斥锁，又被称为“独占锁”。顾名思义，ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。<br><a id="more"></a></p><h2 id="ReentrantLock互斥锁"><a href="#ReentrantLock互斥锁" class="headerlink" title="ReentrantLock互斥锁"></a>ReentrantLock互斥锁</h2><h3 id="常规使用方式"><a href="#常规使用方式" class="headerlink" title="常规使用方式"></a>常规使用方式</h3><p><code>创建锁对象：Lock lock = new ReentrantLock();</code><br><code>锁代码：lock.lock();.......锁的内容；.......lock.unlock();</code></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>尝试获取锁：boolean locked = lock.tryLock();//根据locked值去判定执行什么样的代码</li><li>尝试超时：boolean locked=lock.tryLock(5, TimeUnit.SECONDS);//尝试获取lock锁对象5秒</li><li>可打断：lock.lockInterruptibly(),线程在请求lock并被阻塞时(t1占用了lock锁对象，t2请求被阻塞)，如果此时t2被t3线程interrupt（t2.interrupt()），则“此t2线程会被唤醒并被要求处理InterruptedException”。<br><strong>通俗理解：</strong></li><li>lock(), 拿不到lock就不罢休，不然线程就一直block。 比较无赖的做法。不能被打断</li><li>tryLock()，马上返回，拿到lock就返回true，不然返回false。 比较潇洒的做法。</li><li>带时间限制的tryLock()，拿不到lock，就等一段时间，超时返回false。比较聪明的做法。</li><li>lock.lockInterruptibly()请求锁，请求不到也会一直请求，但是可以被其他线程打断，打断后处理InterruptedException异常，即执行catch和finally代码块</li></ul><h3 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h3><p>（1）synchronized的锁是自动释放的，而ReentrantLock得lock需要手动释放（lock.unlock()）；<br>（2）使用synchronized锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放；<br>（3）ReentrantLock更具灵活性：</p><ul><li>使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待；</li><li>使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应， 在一个线程等待锁的过程中，可以被打断；</li><li>锁可以指定为“公平锁”。<br><code>private static ReentrantLock lock=new ReentrantLock(true)</code></li></ul><p><strong>“公平锁”：</strong>就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中.</p><p><strong>“非公平锁”：</strong>非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReentrantLock&lt;/a&gt;是一个可重入的互斥锁，又被称为“独占锁”。顾名思义，ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>创建线程的两种方式</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/17/Thread/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/17/Thread/</id>
    <published>2017-11-17T15:52:20.000Z</published>
    <updated>2017-12-02T07:47:12.092Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin" target="_blank" rel="external">多线程</a>（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。[1]  在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理（Multithreading）”。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程（台湾译作“执行绪”），进而提升整体处理性能。<br><a id="more"></a></p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p><code>语法：public class A extends Thread{}</code></p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><code>语法：public class A implements Runnable{}</code></p><h3 id="开启线程"><a href="#开启线程" class="headerlink" title="开启线程"></a>开启线程</h3><ul><li><p>情形一：继承Thread类</p><blockquote><p><code>A a=new A();a.start();</code><br><code>说明：开启线程a，并等待执行a对象中的run()方法</code> </p></blockquote></li><li><p>情形二：实现Runnable接口</p><blockquote><p><code>A a=new A();Thread t=new Thread(a);t.start()</code><br><code>说明：开启线程t，并等待执行a对象中的run()方法</code> </p></blockquote></li></ul><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。<br>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。<br>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。</p></blockquote><h3 id="基本原则："><a href="#基本原则：" class="headerlink" title="基本原则："></a>基本原则：</h3><ul><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li></ul><h2 id="start-和-run-的区别说明"><a href="#start-和-run-的区别说明" class="headerlink" title="start() 和 run()的区别说明"></a>start() 和 run()的区别说明</h2><ul><li><strong>start() :</strong> 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</li><li><strong>run():</strong> run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</li></ul><h2 id="wait-notify-notifyAll-等方法介绍"><a href="#wait-notify-notifyAll-等方法介绍" class="headerlink" title="wait(), notify(), notifyAll()等方法介绍"></a>wait(), notify(), notifyAll()等方法介绍</h2><p>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p><ul><li>wait()：让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</li><li>notify()：唤醒在此对象监视器上等待的单个线程。即，唤醒具有同一个此对象锁且正处于等待中的“一个”线程。</li><li>notifyAll()：唤醒在此对象监视器上等待的所有线程。即，唤醒具有同一个此对象锁且正处于等待中的“所有”线程。</li></ul><h2 id="yield-与-wait-的比较"><a href="#yield-与-wait-的比较" class="headerlink" title="yield() 与 wait()的比较"></a>yield() 与 wait()的比较</h2><p>wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：</p><ul><li>wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而yield()是让线程由“运行状态”进入到“就绪状态”。</li><li>wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</li></ul><h2 id="sleep-与-wait-的比较"><a href="#sleep-与-wait-的比较" class="headerlink" title="sleep() 与 wait()的比较"></a>sleep() 与 wait()的比较</h2><blockquote><p>wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p></blockquote><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多线程&lt;/a&gt;（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。[1]  在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理（Multithreading）”。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程（台湾译作“执行绪”），进而提升整体处理性能。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo写博客（三）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/17/HexoWriteArticle/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/17/HexoWriteArticle/</id>
    <published>2017-11-17T02:20:31.000Z</published>
    <updated>2017-11-24T05:18:17.427Z</updated>
    
    <content type="html"><![CDATA[<p>   写博客前的准备工作确实很耗费时间，除了搭建整个Hexo博客环境外，还需要了解Markdowm语法以及通过F12调试功能去定位修改主题配置文件，这些工作弄到熟练，对于新手来说至少需要两到3天，所以不要慌，慢慢接受，等熬到今天写博客这一步你就基本胜利了。<br><a id="more"></a></p><h2 id="Hexo写文章"><a href="#Hexo写文章" class="headerlink" title="Hexo写文章"></a>Hexo写文章</h2><h3 id="第一步：新建文章"><a href="#第一步：新建文章" class="headerlink" title="第一步：新建文章"></a>第一步：新建文章</h3><blockquote><p>新建文章的方式有以下三种：</p></blockquote><ul><li><p><strong>方式一</strong>：直接在”hexo\source_posts”此目录下新建.md文件。有些电脑新手可能不知道怎么弄文件扩展名这一块，而且windows系统是默认是隐藏了文件扩展名的，那么可以通过以下方式打开此扩展名显示按钮：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-8b0fde4e8a4fc60e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p></li><li><p><strong>方式二</strong>：在GitBash控制台输入命令：hexo new “文件名”</p></li><li><p><strong>方式三</strong>：使用MarkdownPad编辑器，在编辑器内点击新建即可。文章编写完成后记得放在”hexo\source_posts”目录下。</p></li></ul><h3 id="第二步：书写正文"><a href="#第二步：书写正文" class="headerlink" title="第二步：书写正文"></a>第二步：书写正文</h3><blockquote><p>正文内容需要记住以下几点：</p></blockquote><ul><li><p>第一：文章Title和Date要记得修改，这两方面对今后的文章归档有很大帮助；</p></li><li><p>第二：文章撰写过程一定要参照右侧预览窗口，虽然有些功能不能预览，但是整体的参考性还是有的，至少可以看到预想的布局。</p></li><li><p>第三：由于各主题风格不一样，有的文章在文章最后没有上一页或者下一页等按钮，我的建议是先预留此板块，当某个章节或者模块完成后，再进行添加。因为涉及到前后页跳转的问题，还是很容易出现先后顺序错乱的问题。</p></li><li><p>第四：写文章还是要注重整体的布局，好的布局让人才有看下去的欲望，才能更好的吸引读者。所以，文章除了有内容，一定也要考虑布局和排版。</p></li></ul><h3 id="第三步：本地预览"><a href="#第三步：本地预览" class="headerlink" title="第三步：本地预览"></a>第三步：本地预览</h3><blockquote><p>在GitBash控制台输入命令：hexo g（生成页面）</p></blockquote><ul><li><code>Administrator@Lenovo-PC MINGW64 /d/persional_website/hexo</code></li><li><code>$ hexo d</code></li></ul><blockquote><p>在GitBash控制台输入命令：hexo s（开启本地服务）</p></blockquote><ul><li><code>Administrator@Lenovo-PC MINGW64 /d/persional_website/hexo</code></li><li><code>$ hexo s</code></li></ul><blockquote><p>输入网址：localhost:4000查看预览效果。</p></blockquote><ul><li><strong>注意:</strong>在本地服务的情况下，使用预览效果，在动态修改.md文件的情况，只要点击保存，刷新网页<br>后，修改内容即会同步到网页上来</li></ul><blockquote><p>部署到Github仓库：</p></blockquote><ul><li><code>Administrator@Lenovo-PC MINGW64 /d/persional_website/hexo</code></li><li><code>$ hexo d</code></li></ul><h2 id="Hexo之新建页面"><a href="#Hexo之新建页面" class="headerlink" title="Hexo之新建页面"></a>Hexo之新建页面</h2><p>新建页面的方式实质是用来设置以下选项的内容的，当然有些选项的内容在主题中已经有了固定的格式，如果你不想要，其实也是可以更换的。那么，下面我们就来介绍一下，如何进行更换。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-38849ebea9ccf0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><blockquote><p>控制台输入命令：</p></blockquote><ul><li><code>hexo new page &quot;文件名&quot;</code></li></ul><blockquote><p>找到文件：</p></blockquote><ul><li><code>...hexo\source\..此路径下可找到以新建文件名命名的文件夹</code></li></ul><blockquote><p>修改主题配置_config.yml文件：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-c4f83e24a865c243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><ul><li><code>/文件名，即可完成设置工作</code></li></ul><blockquote><p>修改页面：</p></blockquote><ul><li><code>...hexo\source\新建文件名，在这个目录下修改里面的index.md文件</code><br>完成以上几步，页面部分就已经介绍完成。希望以上内容对大家能有所帮助！</li></ul><hr><p>到此，关于Hexo搭建个人博客的内容已全部结束，后续也将不断进行完善！欢迎有志之士一同进行探讨和研究，如果你有充足的时间，前期可以在页面整体布局上多花点功夫，确实可以通过Hexo作出自己心目中所想要的网站。世上无难事，只怕有心人！</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   写博客前的准备工作确实很耗费时间，除了搭建整个Hexo博客环境外，还需要了解Markdowm语法以及通过F12调试功能去定位修改主题配置文件，这些工作弄到熟练，对于新手来说至少需要两到3天，所以不要慌，慢慢接受，等熬到今天写博客这一步你就基本胜利了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
