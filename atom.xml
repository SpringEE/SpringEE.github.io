<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BiG哥|博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/SpringEE/SpringEE.github.io/"/>
  <updated>2017-11-29T06:04:57.780Z</updated>
  <id>https://github.com/SpringEE/SpringEE.github.io/</id>
  
  <author>
    <name>BiG哥|博客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程（二）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/24/volatile_synchronized/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/24/volatile_synchronized/</id>
    <published>2017-11-24T15:52:20.000Z</published>
    <updated>2017-11-29T06:04:57.780Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin" target="_blank" rel="external">多线程</a>中最容易混淆和最值得考究的一个问题，就是研究volatile和synchronized的区别，这两个关键字主要用在两个线程共享同一个对象的情况，当对象的属性值更改后，对线程内用到该属性参数的影响。<br><a id="more"></a><br>  一般情况下，两个线程虽然共享了同一个对象，在new Thread（obj）的时候，obj对象的属性i就会从主内存中拷贝到线程的工作内存中，两个线程拷贝同样的初始值i；启动两线程，当有线程1对i进行了修改，线程2是不知道的，依旧使用自身工作内存中的i，而此时主内存中的值已经是修改后的值。这就涉及到JMM内存模型：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-b59fb934a80f06c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h3 id="原子性和可见性"><a href="#原子性和可见性" class="headerlink" title="原子性和可见性"></a>原子性和可见性</h3><ul><li><strong>可见性：</strong>一个线程对共享变量进行修改，修改后能及时的被其他线程看到。</li><li><strong>原子性：</strong>即不可再分了，不能分为多步操作。比如赋值或者return。比如”a = 1;”和 “return a;”这样的操作都具有原子性。类似”a += b”这样的操作不具有原子性，在某些JVM中”a += b”可能要经过这样三个步骤：①　取出a和b；②　计算a+b；③　将计算结果写入内存。</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-81d6a3f9e82f317c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><blockquote><p>volatile关键字，保证了可见性，即线程1对变量进行了修改，他能保证线程2在读取这个变量时，读取到的都是最新值。但volatile不具备原子性，对i++此类不具备原子性的运算操作，如果线程2先读取了i值，但是还未进行计算，此时由于i++不具备原子性，线程2被线程1打断，线程1修改了i值，此时虽然内存中都更新到了最新值，但是线程2由于已经读取过了，不会回头再去检查读取的是否为最新的，而是继续执行下面代码，于是线程2的结果只是覆盖了缓存中的值。</p></blockquote><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>synchronized保证代码具有原子性和可见性，可见性保证每次读取到的是最新值，原子性保证在整个操作过程中确保代码执行的原子性，不可分割。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-5a3c1a82d860b68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br>以上代码synchronized部分，保证每次读取i时，读的都是最新值，且在i++问题上不会被打断，执行完之后若又存在修改，再次读取时将又是最新的i值。synchronized保证了，修改i值操作要么在读取i之前，要么在i写回内存后。</p><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ul><li>1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</li><li>2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</li><li>3）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.</li><li>4）volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</li></ul><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多线程&lt;/a&gt;中最容易混淆和最值得考究的一个问题，就是研究volatile和synchronized的区别，这两个关键字主要用在两个线程共享同一个对象的情况，当对象的属性值更改后，对线程内用到该属性参数的影响。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CountDownLatch浅析</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/22/CountDownLatch/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/22/CountDownLatch/</id>
    <published>2017-11-22T15:52:20.000Z</published>
    <updated>2017-12-02T06:42:11.957Z</updated>
    
    <content type="html"><![CDATA[<p>   一个案例，轻松掌握CountDownLatch（门闩）用法。CountDownLatch是一个同步辅助类，是通过“共享锁”实现的。在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。下面只需通过下面这个案例，就可以基本了解CountDownLatch的用途和用法了。<br><a id="more"></a></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="http://upload-images.jianshu.io/upload_images/9194313-ca5391daa2300c55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br>案例中使用到了CountDownLatch的三个常用方法，从案例中抽取CountDownLatch的三个常用方法进行解读。</p><h3 id="new-CountDownLatch-int-count"><a href="#new-CountDownLatch-int-count" class="headerlink" title="new CountDownLatch(int count)"></a>new CountDownLatch(int count)</h3><p><code>CountDownLatch menShuan = new CountDownLatch(5);</code><br>创建一个门闩，并初始化门闩计数器的数字为5,在CountDownLatch中，计数器是不可以被重置的，计数器的作用就是当count减到0时，唤醒使用menShuan.await（）正在等待中的线程。</p><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h3><p><code>menShuan.countDown()：调用一次countDown()，门闩计数器减1</code><br>递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</p><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p><code>menShuan.await()：主线程等待门闩计数器减至0时，获取共享锁</code><br>使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   一个案例，轻松掌握CountDownLatch（门闩）用法。CountDownLatch是一个同步辅助类，是通过“共享锁”实现的。在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。下面只需通过下面这个案例，就可以基本了解CountDownLatch的用途和用法了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并发集合类-(ConcurrencyClass)</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/20/ConcurrencyClass/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/20/ConcurrencyClass/</id>
    <published>2017-11-20T15:52:20.000Z</published>
    <updated>2017-12-02T07:28:37.522Z</updated>
    
    <content type="html"><![CDATA[<p>   本文主要针对并发的集合类进行一个简单的内容讲解，让读者能够一目了然，如果需要具体了解底层的原理，可以参看网上一些比较好的解读文章，从底层了解这些支持并发的集合类。在之前学习的集合类中，Vector和HashTable都是线程安全的，下面就开始支持并发的集合类。<br><a id="more"></a></p><h2 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote><p>(1)-<strong>ConcurrentHashMap</strong>是线程安全的哈希表。HashMap是非线程安全的哈希表，常用于单线程程序中；Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的；Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。<br>(2)-<strong>ConcurrentHashMap</strong>是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。</p></blockquote><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的时，它具有以下特性：</p><blockquote><p>(1)-它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。<br>(2)-它是线程安全的。<br>(3)-因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大<br>(4)-迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作。<br>(5)-使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p></blockquote><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><blockquote><p>它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表(HashMap)”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。<br>ConcurrentSkipListMap:</p></blockquote><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><blockquote><p>ConcurrentSkipListMap是线程安全的有序的哈希表，适用于高并发的场景。ConcurrentSkipListMap和TreeMap，它们虽然都是有序的哈希表。但是，第一，它们的线程安全机制不同，TreeMap是非线程安全的，而ConcurrentSkipListMap是线程安全的。第二，ConcurrentSkipListMap是通过跳表实现的，而TreeMap是通过红黑树实现的。关于跳表(Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。</p></blockquote><h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><blockquote><p>(1)–ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。<br>(2)–ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。</p></blockquote><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><blockquote><p>(1)–ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。<br>线程安全是指，ArrayBlockingQueue内部通过“互斥锁”保护竞争资源，实现了多线程对竞争资源的互斥访问。而有界，则是指ArrayBlockingQueue对应的数组是有界限的。 阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待；而且，ArrayBlockingQueue是按 FIFO（先进先出）原则对元素进行排序，元素都是从尾部插入到队列，从头部开始返回。<br>(2)–注意：ArrayBlockingQueue不同于ConcurrentLinkedQueue，ArrayBlockingQueue是数组实现的，并且是有界限的；而ConcurrentLinkedQueue是链表实现的，是无界限的。</p></blockquote><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><blockquote><p>(1)–LinkedBlockingQueue是一个单向链表实现的阻塞队列。该队列按 FIFO（先进先出）排序元素，新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。<br>(2)–此外，LinkedBlockingQueue还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE。</p></blockquote><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><blockquote><p>(1)–LinkedBlockingDeque是双向链表实现的双向并发阻塞队列。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)；并且，该阻塞队列是支持线程安全。<br>(2)–此外，LinkedBlockingDeque还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE。</p></blockquote><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><blockquote><p>ConcurrentLinkedQueue是线程安全的队列，它适用于“高并发”的场景。<br>它是一个基于链接节点的无界线程安全队列，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置null元素（内部实现的特殊节点除外）。</p></blockquote><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   本文主要针对并发的集合类进行一个简单的内容讲解，让读者能够一目了然，如果需要具体了解底层的原理，可以参看网上一些比较好的解读文章，从底层了解这些支持并发的集合类。在之前学习的集合类中，Vector和HashTable都是线程安全的，下面就开始支持并发的集合类。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生产者和消费者</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/20/ProducerAndConsumer/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/20/ProducerAndConsumer/</id>
    <published>2017-11-20T11:03:35.000Z</published>
    <updated>2017-11-30T14:03:21.189Z</updated>
    
    <content type="html"><![CDATA[<p>多线程中的生产者和消费者案例，非常具有研究性，也值得考究。这就好比理科生解高数一样，越推理越有激情，而无法自拔。下面介绍一下比较易懂的一个生产者和消费者案例：写一个固定容量同步容器，拥有put和get方法，能够支持3个生产者线程以及10个消费者线程的阻塞调用。</p><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><h3 id="案例内容分析："><a href="#案例内容分析：" class="headerlink" title="案例内容分析："></a>案例内容分析：</h3><ul><li><p>需要一个同步容器，可以往里添加元素，也可以往外拿元素；<br><strong>解读1：</strong>需要一个容器，我们只对其进行添加和删除操作，从所学知识list和Map中，我们选择了LinckedList,因为LinckedList底层采用是双链表结构，而链表的结构相对ArraryList就是增删效率高，ArraryList由于底层使用的是数组，可以通过角标进行查询，所以选择了LinckedList。而且LinckedList在删除时会返回锁删除的元素值。<br><strong>解读2：</strong>容器是同步的，所以在增删的过程中，是不能被打扰的，即在增的时候，别人不能删和增。所以，这两个方法都应该上锁，且锁对象是这个容器。所有，我们到这里，大致可以模拟出这个容器的框架了：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-6117d277dba7378b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p></li><li><p>能够支持3个生产者线程以及10个消费者线程的阻塞调用<br><strong>解读：</strong>创建三个线程，去调用生产方法（put方法）；创建10个线程，去掉用消费方法（get方法）。用上for循环即可。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-6efb66c08d53fd73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p></li></ul><h3 id="细节解读"><a href="#细节解读" class="headerlink" title="细节解读"></a>细节解读</h3><p><code>1）for(int i=0;i&lt;10;i++){new Thread(new Runnable(){...}）.start（）}</code></p><blockquote><p>创建了十个线程用来执行new Runnable()实例的run方法，因为循环了10次，所以每个new Runnable()实例是不一样的。10个线程执行run()方法在不考虑run()里面的代码情况下，是互不影响的，因为有每个线程对应一个新的new Runnable()实例。所以，可能线程1在执行run方法的时候，线程2也在执行run方法。</p></blockquote><p><code>2）sync.put(manTou);</code></p><blockquote><p>不管是生产者还是消费者，线程的run（）方法里，都需要的是同一个锁对象，这时候问题就来了，13个线程开始出现了关联。即使两个线程同时执行了run()但是没有锁，也无法继续往下。线程1执行完了，释放了锁，线程2才能获得锁执行run()方法里面的代码。</p></blockquote><p><code>3)...run() {for(...){sync.put(manTou);}}</code>        `</p><blockquote><p>run()内面的for是可以抽象理解为是能够被其他线程“打断”的，这里的打断只得是该线程循环一次后，执行完了一次sync.put(manTou);}，释放了锁，这时锁被第二个线程拿到了，那么再进行第二次循环时，该线程只能等到另外的线程释放锁了再执行。</p></blockquote><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多线程中的生产者和消费者案例，非常具有研究性，也值得考究。这就好比理科生解高数一样，越推理越有激情，而无法自拔。下面介绍一下比较易懂的一个生产者和消费者案例：写一个固定容量同步容器，拥有put和get方法，能够支持3个生产者线程以及10个消费者线程的阻塞调用。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>守护线程（Daemon）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/19/Daemon/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/19/Daemon/</id>
    <published>2017-11-19T11:03:35.000Z</published>
    <updated>2017-11-29T11:20:01.705Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护线程-又称后台线程，英文：Daemon"><a href="#守护线程-又称后台线程，英文：Daemon" class="headerlink" title="守护线程(又称后台线程，英文：Daemon)"></a>守护线程(又称后台线程，英文：Daemon)</h3><blockquote><p>是指在程序运行的时候，在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。<strong>因此，当所有非后台线程执行结束后，程序也将终止。</strong><br>同时会杀死所有后台线程，<strong>反过来，只要有任何非后台线程还在运行，程序就不会终止。</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-abe812f11db8570f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br><img src="http://upload-images.jianshu.io/upload_images/9194313-13e93d91743c3136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><ul><li>如果是后台线程，程序马上终止。</li><li>如果不是后台线程，主线程main()将等待5s，即子线程结束时，结束。</li><li>例如：t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;守护线程-又称后台线程，英文：Daemon&quot;&gt;&lt;a href=&quot;#守护线程-又称后台线程，英文：Daemon&quot; class=&quot;headerlink&quot; title=&quot;守护线程(又称后台线程，英文：Daemon)&quot;&gt;&lt;/a&gt;守护线程(又称后台线程，英文：Daemon)
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/18/ReentrantLock/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/18/ReentrantLock/</id>
    <published>2017-11-18T15:52:20.000Z</published>
    <updated>2017-11-29T15:01:44.446Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin" target="_blank" rel="external">ReentrantLock</a>是一个可重入的互斥锁，又被称为“独占锁”。顾名思义，ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。<br><a id="more"></a></p><h2 id="ReentrantLock互斥锁"><a href="#ReentrantLock互斥锁" class="headerlink" title="ReentrantLock互斥锁"></a>ReentrantLock互斥锁</h2><h3 id="常规使用方式"><a href="#常规使用方式" class="headerlink" title="常规使用方式"></a>常规使用方式</h3><p><code>创建锁对象：Lock lock = new ReentrantLock();</code><br><code>锁代码：lock.lock();.......锁的内容；.......lock.unlock();</code></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>尝试获取锁：boolean locked = lock.tryLock();//根据locked值去判定执行什么样的代码</li><li>尝试超时：boolean locked=lock.tryLock(5, TimeUnit.SECONDS);//尝试获取lock锁对象5秒</li><li>可打断：lock.lockInterruptibly(),线程在请求lock并被阻塞时(t1占用了lock锁对象，t2请求被阻塞)，如果此时t2被t3线程interrupt（t2.interrupt()），则“此t2线程会被唤醒并被要求处理InterruptedException”。<br><strong>通俗理解：</strong></li><li>lock(), 拿不到lock就不罢休，不然线程就一直block。 比较无赖的做法。不能被打断</li><li>tryLock()，马上返回，拿到lock就返回true，不然返回false。 比较潇洒的做法。</li><li>带时间限制的tryLock()，拿不到lock，就等一段时间，超时返回false。比较聪明的做法。</li><li>lock.lockInterruptibly()请求锁，请求不到也会一直请求，但是可以被其他线程打断，打断后处理InterruptedException异常，即执行catch和finally代码块</li></ul><h3 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h3><p>（1）synchronized的锁是自动释放的，而ReentrantLock得lock需要手动释放（lock.unlock()）；<br>（2）使用synchronized锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放；<br>（3）ReentrantLock更具灵活性：</p><ul><li>使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待；</li><li>使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应， 在一个线程等待锁的过程中，可以被打断；</li><li>锁可以指定为“公平锁”。<br><code>private static ReentrantLock lock=new ReentrantLock(true)</code></li></ul><p><strong>“公平锁”：</strong>就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中.</p><p><strong>“非公平锁”：</strong>非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ReentrantLock&lt;/a&gt;是一个可重入的互斥锁，又被称为“独占锁”。顾名思义，ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo写博客（三）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/17/HexoWriteArticle/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/17/HexoWriteArticle/</id>
    <published>2017-11-17T02:20:31.000Z</published>
    <updated>2017-11-24T05:18:17.427Z</updated>
    
    <content type="html"><![CDATA[<p>   写博客前的准备工作确实很耗费时间，除了搭建整个Hexo博客环境外，还需要了解Markdowm语法以及通过F12调试功能去定位修改主题配置文件，这些工作弄到熟练，对于新手来说至少需要两到3天，所以不要慌，慢慢接受，等熬到今天写博客这一步你就基本胜利了。<br><a id="more"></a></p><h2 id="Hexo写文章"><a href="#Hexo写文章" class="headerlink" title="Hexo写文章"></a>Hexo写文章</h2><h3 id="第一步：新建文章"><a href="#第一步：新建文章" class="headerlink" title="第一步：新建文章"></a>第一步：新建文章</h3><blockquote><p>新建文章的方式有以下三种：</p></blockquote><ul><li><p><strong>方式一</strong>：直接在”hexo\source_posts”此目录下新建.md文件。有些电脑新手可能不知道怎么弄文件扩展名这一块，而且windows系统是默认是隐藏了文件扩展名的，那么可以通过以下方式打开此扩展名显示按钮：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-8b0fde4e8a4fc60e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p></li><li><p><strong>方式二</strong>：在GitBash控制台输入命令：hexo new “文件名”</p></li><li><p><strong>方式三</strong>：使用MarkdownPad编辑器，在编辑器内点击新建即可。文章编写完成后记得放在”hexo\source_posts”目录下。</p></li></ul><h3 id="第二步：书写正文"><a href="#第二步：书写正文" class="headerlink" title="第二步：书写正文"></a>第二步：书写正文</h3><blockquote><p>正文内容需要记住以下几点：</p></blockquote><ul><li><p>第一：文章Title和Date要记得修改，这两方面对今后的文章归档有很大帮助；</p></li><li><p>第二：文章撰写过程一定要参照右侧预览窗口，虽然有些功能不能预览，但是整体的参考性还是有的，至少可以看到预想的布局。</p></li><li><p>第三：由于各主题风格不一样，有的文章在文章最后没有上一页或者下一页等按钮，我的建议是先预留此板块，当某个章节或者模块完成后，再进行添加。因为涉及到前后页跳转的问题，还是很容易出现先后顺序错乱的问题。</p></li><li><p>第四：写文章还是要注重整体的布局，好的布局让人才有看下去的欲望，才能更好的吸引读者。所以，文章除了有内容，一定也要考虑布局和排版。</p></li></ul><h3 id="第三步：本地预览"><a href="#第三步：本地预览" class="headerlink" title="第三步：本地预览"></a>第三步：本地预览</h3><blockquote><p>在GitBash控制台输入命令：hexo g（生成页面）</p></blockquote><ul><li><code>Administrator@Lenovo-PC MINGW64 /d/persional_website/hexo</code></li><li><code>$ hexo d</code></li></ul><blockquote><p>在GitBash控制台输入命令：hexo s（开启本地服务）</p></blockquote><ul><li><code>Administrator@Lenovo-PC MINGW64 /d/persional_website/hexo</code></li><li><code>$ hexo s</code></li></ul><blockquote><p>输入网址：localhost:4000查看预览效果。</p></blockquote><ul><li><strong>注意:</strong>在本地服务的情况下，使用预览效果，在动态修改.md文件的情况，只要点击保存，刷新网页<br>后，修改内容即会同步到网页上来</li></ul><blockquote><p>部署到Github仓库：</p></blockquote><ul><li><code>Administrator@Lenovo-PC MINGW64 /d/persional_website/hexo</code></li><li><code>$ hexo d</code></li></ul><h2 id="Hexo之新建页面"><a href="#Hexo之新建页面" class="headerlink" title="Hexo之新建页面"></a>Hexo之新建页面</h2><p>新建页面的方式实质是用来设置以下选项的内容的，当然有些选项的内容在主题中已经有了固定的格式，如果你不想要，其实也是可以更换的。那么，下面我们就来介绍一下，如何进行更换。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-38849ebea9ccf0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><blockquote><p>控制台输入命令：</p></blockquote><ul><li><code>hexo new page &quot;文件名&quot;</code></li></ul><blockquote><p>找到文件：</p></blockquote><ul><li><code>...hexo\source\..此路径下可找到以新建文件名命名的文件夹</code></li></ul><blockquote><p>修改主题配置_config.yml文件：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-c4f83e24a865c243.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><ul><li><code>/文件名，即可完成设置工作</code></li></ul><blockquote><p>修改页面：</p></blockquote><ul><li><code>...hexo\source\新建文件名，在这个目录下修改里面的index.md文件</code><br>完成以上几步，页面部分就已经介绍完成。希望以上内容对大家能有所帮助！</li></ul><hr><p>到此，关于Hexo搭建个人博客的内容已全部结束，后续也将不断进行完善！欢迎有志之士一同进行探讨和研究，如果你有充足的时间，前期可以在页面整体布局上多花点功夫，确实可以通过Hexo作出自己心目中所想要的网站。世上无难事，只怕有心人！</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   写博客前的准备工作确实很耗费时间，除了搭建整个Hexo博客环境外，还需要了解Markdowm语法以及通过F12调试功能去定位修改主题配置文件，这些工作弄到熟练，对于新手来说至少需要两到3天，所以不要慌，慢慢接受，等熬到今天写博客这一步你就基本胜利了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo写博客（二）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/16/HexoArticleStyle/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/16/HexoArticleStyle/</id>
    <published>2017-11-16T12:02:00.000Z</published>
    <updated>2017-11-24T05:06:39.898Z</updated>
    
    <content type="html"><![CDATA[<p>   Hexo的Markdown语法学习完之后，下面将主要介绍关系到文章布局的文件信息，至于具体怎么修改，文件位置在哪里，这里也只能给大家提供参考，毕竟不同的主题，文件夹的布局方式是不一样的，但是大体的布局相似度还是很高的。上篇文章由于篇幅太长，关于MarkDown的一些注意事项和界面说明在此先做一下补充说明。<br><a id="more"></a></p><hr><h2 id="MarkDown语法补充："><a href="#MarkDown语法补充：" class="headerlink" title="MarkDown语法补充："></a>MarkDown语法补充：</h2><ul><li><p>代码语法中，可以写中文汉字，不一定全是代码英文；</p></li><li><p>关于开头空两个字符，这种语法MarkDown中没有，是有article样式控制的；</p></li><li><p>关于语法影响布局的问题，可以在此语法前后各加一段空行，因为有的语法使用时必须要前后空一行的；</p></li><li><p>语法嵌套，有很多都是不行的，想用也用不了，没办法实现，只能另想布局。</p></li><li><p>换行的实现：换行实现方式，按两下“空格”，然后再按一下“回撤”就可以了。</p></li></ul><hr><h2 id="MarkDownPad（-md文档编辑器）界面简介："><a href="#MarkDownPad（-md文档编辑器）界面简介：" class="headerlink" title="MarkDownPad（.md文档编辑器）界面简介："></a>MarkDownPad（.md文档编辑器）界面简介：</h2><ul><li><p>界面展示</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-06330fe1a29cce7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p></blockquote></li><li><p>界面内容及工具都比较简单，标示完各工具图标所代表的含义，相信对初学者的你们一定有很大帮助。但是有一点还是需要提醒一下各位，MarkdownPad编辑器使用工具快捷语法，不一定都好使，当然，容易出状况的也只是个别。下面只提一下Markdown中的链接这一块：</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-afb9f77fab864b22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p></blockquote></li><li><p>但是上面这串代码的显示效果并非是所想要的，这就是这款编辑器自身所还存在的一些遗漏问题，不过没关系，请看下面的解决方案：</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-be520175c71bf811.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p></blockquote></li><li><p>虽然按照以上代码可以实现比较好的代码，但是点击文字依然会报错，所以还需要手动修改才能达到预期的目的，只需要修改为MarkDown标准语法格式即可，看图中“最终”字样所指向的代码。</p></li></ul><hr><h2 id="博客样式优化："><a href="#博客样式优化：" class="headerlink" title="博客样式优化："></a>博客样式优化：</h2><h3 id="文件目录说明"><a href="#文件目录说明" class="headerlink" title="文件目录说明"></a>文件目录说明</h3><blockquote><p>在整个样式调整和设置过程中，主要用到的文件代码格式分别为.styl和.ejs两种格式的文件，各主题的文件取名也是“一目了然”，相信找到对应的文件夹，就可以找到你所想要的文件，下面就是修改代码的工作了。所以，了解这些文件所在的目录，非常重要：</p></blockquote><ul><li>博客文件的目录：<br>  <code>hexo\source\_posts</code></li><li>页面图片目录（更换头像和标题小图标会用到）：<br>  <code>hexo\public\img</code></li><li>.ejs文件目录（.ejs类似html代码，一般都能看懂）：<br>  <code>hexo\themes\pacman（主题名）\layout</code></li><li>.styl文件目录（样式布局调整用到）：<br>  <code>hexo\themes\pacman\source\css</code><br><a href="http://upload-images.jianshu.io/upload_images/9194313-996546b91c9a886b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">04.png</a></li></ul><h3 id="网页内容定位"><a href="#网页内容定位" class="headerlink" title="网页内容定位"></a>网页内容定位</h3><blockquote><p>考虑到新手较多，下面还是讲一下页面内容的具体定位方式，只要定位到了文件的具体位置，那么就可以根据自身的Java基础进行尝试性调整，不仅可以“增删改”，而且还能修改样式、颜色和布局。具体定位请参照下图：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-fe5f9e481cf4e986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"></p><h3 id="尝试修改样式"><a href="#尝试修改样式" class="headerlink" title="尝试修改样式"></a>尝试修改样式</h3><blockquote><p>通过修改与选中内容相关的样式，来确定自己所找到的是否为所期望的，这里标题的颜色直接定位在了h6这个样式位置，在article文件中依次根据.article-content h6，找到与h6相关的样式，如图：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/9194313-c482bdb1c18886de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"></p><ul><li>修改文章对应的颜色值，将“color-heading”改为“#ffffff”，保存后刷新localhost:4000，会发现文字颜色变化了，那么，你就找对了，然后改成你想要的样式即可。至于“增删改”，同样，找对应的文件和位置，对内容进行调整即可。相信，都很容易上手的，只要有耐心去定位你要修改的内容文件位置，各种样式颜色，随便你怎么玩都可以。</li><li><strong>说明</strong>：像这种color-heading这种属性的设置，都是在全局中已经设置好的，至于具体位置和路径，可以参照以下路径，只不过再改动就是改全局的了，所有与之相关的（用到color-heading属性的都会变更）。改全局和局部都是可以的。文件路径：<br><code>hexo\themes\pacman\source\css\_base</code></li></ul><p>More info: <a href="http://www.javait.club/2017/11/17/HexoWriteArticle/" target="_blank" rel="external">Hexo写博客（三）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   Hexo的Markdown语法学习完之后，下面将主要介绍关系到文章布局的文件信息，至于具体怎么修改，文件位置在哪里，这里也只能给大家提供参考，毕竟不同的主题，文件夹的布局方式是不一样的，但是大体的布局相似度还是很高的。上篇文章由于篇幅太长，关于MarkDown的一些注意事项和界面说明在此先做一下补充说明。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo写博客（一）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/16/HexoArticle/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/16/HexoArticle/</id>
    <published>2017-11-16T08:43:46.000Z</published>
    <updated>2017-11-24T07:06:47.442Z</updated>
    
    <content type="html"><![CDATA[<p>   Hexo个人博客网站搭建完成后，剩下的就是写博客！但是，写博客也并非写普通文档一样简单，Hexo的博客文件在<strong>hexo－＞source－＞_posts</strong>这个目录下，文件后缀名为.md，使用的是一套Markdown语法，所以，写博客之前，就必须要了解此语法。本文将从开始到结尾，以新手的角度来打造这篇博客。<br><a id="more"></a></p><h2 id="Hexo写博客之准备工作："><a href="#Hexo写博客之准备工作：" class="headerlink" title="Hexo写博客之准备工作："></a>Hexo写博客之准备工作：</h2><ul><li>注册<a href="https://www.jianshu.com/sign_up" target="_blank" rel="external">简书</a>，前段时间用的“贴图库”的图片服务器，后来发现图片超过7天会自动删除，否者就要付费，于是立马转战<a href="https://www.jianshu.com/sign_up" target="_blank" rel="external">简书</a>。将<a href="https://www.jianshu.com/sign_up" target="_blank" rel="external">简书</a>的文档格式改成Markdown格式，将图片拖入文本内容中，会自动生成markdown语法语句，复制即可。<blockquote><p>那么有人可能会问，<strong>为什么要使用图片服务器</strong>？  　　<br>　　将图片上传至github仓库之后，使用github仓库中的链接并不能达到预期的效果，直接使用百度图片的链接也达不到预期的效果，那么最好的方式就是注册一个图片服务器，有好友说“简书”也可以。当然方式很多，但我个人是推荐使用“简书”。建议图片在本地最好有备份，以免出现不可抗力因素导致图片服务器出现异常。“简书”使用效果图：<br>　　<img src="http://upload-images.jianshu.io/upload_images/9194313-76b01d219d4e622c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p></blockquote></li></ul><p>　　注册链接：<a href="http://www.tietuku.com/login" target="_blank" rel="external">http://www.tietuku.com/login</a></p><ul><li>安装<a href="http://markdownpad.com/download.html" target="_blank" rel="external">MarkdownPad2</a>，MarkdownPad2是.md文件的编辑器，有很多语法快捷按钮，学习起来也很容易上手，另外还有预览效果图，如下：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-268e285eb10d276d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></li></ul><h2 id="Hexo写博客之Markdown语法："><a href="#Hexo写博客之Markdown语法：" class="headerlink" title="Hexo写博客之Markdown语法："></a>Hexo写博客之Markdown语法：</h2><p>关于“Markdown语法”的文章也很多，但讲解的内容有的非常详细但是特别难懂，一时间抓不到重点，废话太多，有的是写的简明，但写不出重点，不过本人的观点还是先分享链接再做个人分析解读。前辈们的链接有很多：</p><ol><li><p><a href="http://www.jianshu.com/p/f7305002a30f" target="_blank" rel="external">http://www.jianshu.com/p/f7305002a30f</a></p></li><li><p><a href="http://wowubuntu.com/markdown/#blockquote" target="_blank" rel="external">http://wowubuntu.com/markdown/#blockquote</a></p></li></ol><p><strong>下面以新手的角度来解读常用的几个Markdown语法：</strong></p><h3 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h3><blockquote><p>标题的语法很简单，标题的层次感也比较鲜明，主要是看什么样的字体大小你觉得合适，就使用几级标题，Markdown中最常用的6个档次：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-0b7fd13ed8caef6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p></blockquote><ul><li>语法：<code>### 你好 或者 ### 你好 ###</code>  </li><li>注意：有些“主题”可能有由于样式原因，使得标题的各档次的使用功能不能全备，像我这个主题最多只能使用3级，但是右侧预览字体的大小确实会根据标题的层次而发生变化，这就需要对主题的样式及配置文件进行设置了，但是一动可能就要改很多地方，所以暂时不建议有所修改，先将就着用吧。</li><li>忌讳：一定要在文字和“#”之间加上空格，否则标题不生效。同时可以在标题前后各空一行，以免影响文章的排版。</li></ul><h3 id="列表语法："><a href="#列表语法：" class="headerlink" title="列表语法："></a>列表语法：</h3><blockquote><p>列表语法也分为两种：有序和无序。不过规则都比较单一，有序是以阿拉伯数字“1”开始，自动递增；无序是以“-”开始，代表的是个实心圆圈“·”。这两种语法在排版中用到的较多，具体语法如下：<br>    <code>- 文本              1.文本</code><br>    <code>- 文本              2.文本</code><br>    <code>- 文本              3.文本</code><br>这种语法其实在Markdown编辑器里面都有快捷按钮，使用起来相当方便。</p></blockquote><ul><li>实战案例：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-186c6bcf7a76aac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"></li><li>忌讳：“-”、“1.”和“文本”之间要保留一个字符的空格。</li></ul><h3 id="链接语法："><a href="#链接语法：" class="headerlink" title="链接语法："></a>链接语法：</h3><blockquote><p>链接的情况分两种，一种是图片链接，一种是文字链接。<br>1.文字链接：<strong>[文字]（网址）</strong>。点击文字，即可跳转括号内的链接地址。<br>2.图片链接：<strong>![文字]（图片地址）</strong>。在文章中显示静态图片内容。</p></blockquote><ul><li>实战案例<br>  <code>文字链接：[图片服务器](http://www.tietuku.com/login)</code><br>  <code>图片链接：![List](http://i4.bvimg.com/618561/e4475ed1688e1ff1.png)</code></li><li>注意：图片链接，一定要填写网址，由Markdown编辑器快捷生成的语法，可能有些用不了，但只要记住上面的使用格式，是绝对没问题的。图片网址，即为你图片服务器中上传图片所生成的网址，复制过来，直接就是可以用的。</li></ul><h3 id="引用语法："><a href="#引用语法：" class="headerlink" title="引用语法："></a>引用语法：</h3><blockquote><p>这种语法，我个人理解为是一种排版语法，用来进行页面排版的。使用引用语法可以使页面变得更加有层次感，布局让人耳目一新。但是，这种语法的使用可能会夹杂着一些样式，需要将网页再度优化的可以去样式中进行修改，老方法，用F12去定位。我的“主题”配置文件已经改过很多次了，再此时不太想再此方面花功夫了，直接上图：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-237213fde4443782.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"></p></blockquote><ul><li>语法：&gt;文字 或  &gt;&gt;文字（二级引用）</li></ul><h3 id="字体语法："><a href="#字体语法：" class="headerlink" title="字体语法："></a>字体语法：</h3><blockquote><p>字体语法，一个是斜体，一个是粗体<br><code>斜体语法格式：*文字*</code><br><code>粗体语法格式：**文字**</code><br>效果：<em>效果</em>、<strong>效果</strong></p></blockquote><h3 id="代码语法："><a href="#代码语法：" class="headerlink" title="代码语法："></a>代码语法：</h3><blockquote><p>代码语法也分为两种，一种是单行代码，一种是多行代码。但有一点值得提醒，不管是单行代码还是多行代码，各大类主题都为之设置了样式，都需要自己去样式文件中进行调整，才能达到指定的效果，不管是配色、字体、背景等等这些东西，都是有可能要修改的，想让页面美观，就要多下功夫，代码语法很简单，语法格式：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-743b4314c326e198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"></p></blockquote><h3 id="表格语法："><a href="#表格语法：" class="headerlink" title="表格语法："></a>表格语法：</h3><blockquote><p>此语法运用场景较为罕见，基本不怎么用，但是还是需要提一下，万一用到了呢，以免各位又到处寻找，干脆在此做个简单的普及。当然，都是从学者过来，好东西当然要借鉴，下面就是关于表格语法的一点介绍：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-2ce9865ced3d8f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="07.png"></p></blockquote><hr><p>总结：大部分语法，在MarkDown编辑器中都有快捷键，但有些快捷键和预览效果与实际效果存在着些许差异，建议还是使用localhost:4000本地端口进行调试查看文章效果，以免部署后出现排版问题，麻烦。当然，若出现疑问可参照本文标准格式修改你的文章内容即可，均为作者亲测，下篇文章将对MarkdownPad2编辑工具以及文章样式做详细解读。</p><p>More info: <a href="http://www.javait.club/2017/11/16/HexoArticleStyle/" target="_blank" rel="external">Hexo写博客（二）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   Hexo个人博客网站搭建完成后，剩下的就是写博客！但是，写博客也并非写普通文档一样简单，Hexo的博客文件在&lt;strong&gt;hexo－＞source－＞_posts&lt;/strong&gt;这个目录下，文件后缀名为.md，使用的是一套Markdown语法，所以，写博客之前，就必须要了解此语法。本文将从开始到结尾，以新手的角度来打造这篇博客。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub+常用插件</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/15/HexoGitHub/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/15/HexoGitHub/</id>
    <published>2017-11-15T02:20:31.000Z</published>
    <updated>2017-11-24T06:47:37.202Z</updated>
    
    <content type="html"><![CDATA[<p>   关于个人博客网站的搭建，从<a href="https://www.aliyun.com" target="_blank" rel="external">域名</a>的购买到绑定和注册<a href="https://github.com/hexojs/hexo/issues">GitHub</a>，好文章确实很多，在此就不再做单独的个人文章说明，只分享前辈们“<a href="http://blog.liuxianan.com/build-blog-website-by-hexo-github.html" target="_blank" rel="external">搭建Hexo</a>”的链接。本文的重点将落在各类Hexo插件的整合上，Hexo插件甚多，本文只介绍常见的几种。<br><a id="more"></a></p><h2 id="Hexo搭建个人博客"><a href="#Hexo搭建个人博客" class="headerlink" title="Hexo搭建个人博客"></a>Hexo搭建个人博客</h2><h3 id="博客搭建前的准备工作："><a href="#博客搭建前的准备工作：" class="headerlink" title="博客搭建前的准备工作："></a>博客搭建前的准备工作：</h3><blockquote><p>1.下载安装以下文件：<a href="https://nodejs.org/en/download/" target="_blank" rel="external">node.js</a>/<a href="https://git-scm.com/download/win" target="_blank" rel="external">GitForWindows</a>/<a href="https://nodejs.org/en/download/" target="_blank" rel="external">npm</a>  </p><ul><li>node.js（最新版本的node.js已经集成了npm模块，无需单独安装）<br>(1)下载链接：<a href="https://nodejs.org/en/download" target="_blank" rel="external">https://nodejs.org/en/download</a><br>(2)安装教程：<a href="http://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="external">http://www.cnblogs.com/zhouyu2017/p/6485265.html</a></li><li>Git For Windows（版本控制软件）<br>(1)下载链接：<a href="https://git-for-windows.github.io/" target="_blank" rel="external">https://git-for-windows.github.io/</a><br>(2)安装教程：<a href="https://www.cnblogs.com/vitah/p/3612473.html" target="_blank" rel="external">https://www.cnblogs.com/vitah/p/3612473.html</a> </li></ul><p>2.注册<a href="https://github.com/">GitHub</a>（类似于服务器，用来部署你的项目）</p><ul><li>注册链接：<a href="https://github.com/">https://github.com/</a>  </li><li>使用教程：<a href="https://www.cnblogs.com/zfanlong1314/p/3715490.html" target="_blank" rel="external">https://www.cnblogs.com/zfanlong1314/p/3715490.html</a>  </li><li><strong>备注：</strong>更多细节操作（域名绑定及ssh秘钥配置请）请参照以下链接：<br>   <a href="http://blog.liuxianan.com/build-blog-website-by-hexo-github.html" target="_blank" rel="external">http://blog.liuxianan.com/build-blog-website-by-hexo-github.html</a></li></ul><p>3.安装Hexo(Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具)  </p><ul><li>使用Git Bash执行以下命令（鼠标右键可找到git bash）：<br>  <code>$ npm install -g hexo</code>    </li><li>初始化Hexo（先在本地新建hexo文件夹，然后在此文件夹内右键“git bash”），执行以下代码：<br>  <code>$ hexo init</code></li><li>执行以下代码后，通过<a href="localhost:4000" target="_blank" rel="external">localhost:4000</a>网址查看你自己的网页效果：<br>  <code>$ hexo g</code><br>  <code>$ hexo s</code></li></ul></blockquote><h3 id="Hexo常用命令说明："><a href="#Hexo常用命令说明：" class="headerlink" title="Hexo常用命令说明："></a>Hexo常用命令说明：</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-dbfcc25c0b87a4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br><strong>说明：</strong>很多时候会遇到代码修改后，刷新页面不现实效果，这时候可以直接“hexo clean”命令来清理一些缓存等内容，这个命令使用非常频繁，如果文件有删除或者大的变动，在提交前，建议都使用此命令来进行一次清理，以免造成不必要的麻烦。一般使用都是“hexo g”、“hexo s”通过这两个命令来查看文件部署前的预览效果。前面两个新建按钮，用的比较少，但是重要性还是存在的。  </p><h3 id="Hexo配置文件-config-yml说明"><a href="#Hexo配置文件-config-yml说明" class="headerlink" title="Hexo配置文件_config.yml说明"></a>Hexo配置文件_config.yml说明</h3><blockquote><p>关于_config.yml配置文件这一块详细内容说明请<a href="http://blog.csdn.net/gyq1998/article/details/78294689" target="_blank" rel="external">参考</a>以下链接：<a href="http://blog.csdn.net/gyq1998/article/details/78294689，本人只分享可能会用到的几点做解析。" target="_blank" rel="external">http://blog.csdn.net/gyq1998/article/details/78294689，本人只分享可能会用到的几点做解析。</a><br>    <code>* title：网页标题名称</code><br>    <code>* theme：主体，当你下载完主体后，需要在这里配置你所下载的主体名称</code><br>    <code>* Plugins：插件，以后添加插件需要在此处进行配置</code><br>    <code>* deploy下的repository：此处用来配置你的GitHub仓库地址</code><br>    <code>* url：网址路径，后期可作为全局变量使用拼接路径</code></p></blockquote><h2 id="Hexo常用插件"><a href="#Hexo常用插件" class="headerlink" title="Hexo常用插件"></a>Hexo常用插件</h2><p>以下只简单介绍各插件以及安装方式，但是有一点一定要弄清楚，插件安装了放在哪里？这就是考验你JAVA语言功底的时候了，需要改样式和类似html的语言，这里，提供给大家一个比较好的测试调整方式：F12打开网页调试页面，通过对标签的定位去修改原有主题的样式和内容，达到自己想要的目的，这种样式需要花费时间，需耐心。</p><h3 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h3><blockquote><p>主体插件的安装和配置都比较简单，但是若想找到自己满意的主题，那可就要花点时间了。本连想推荐几个主题，但考虑到排版等问题，下面只向大家介绍各类主题的<a href="https://hexo.io/themes/" target="_blank" rel="external">“Home”</a>，你所要的主体基本都在这里，爱上哪款便可以选择哪款，每款主题都有对应的缩略图。主题链接：<a href="https://hexo.io/themes/。主题安装完成后，需要在hexo配置文件_config.yml中进行配置才能生效" target="_blank" rel="external">https://hexo.io/themes/。主题安装完成后，需要在hexo配置文件_config.yml中进行配置才能生效</a>:<br><img src="http://upload-images.jianshu.io/upload_images/9194313-03516e36858ac945.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p></blockquote><p>主题安装教程：<a href="http://blog.csdn.net/chwshuang/article/details/52350463" target="_blank" rel="external">http://blog.csdn.net/chwshuang/article/details/52350463</a></p><h3 id="日历插件"><a href="#日历插件" class="headerlink" title="日历插件"></a>日历插件</h3><blockquote><p>日历插件的安装和配置，这里有篇比较好的文章，亲测OK！效果图大致如下：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-d703c9b004351f3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br>此插件安装教程：<a href="http://www.jianshu.com/p/b9665a8e8282" target="_blank" rel="external">http://www.jianshu.com/p/b9665a8e8282</a><br><strong>注意：</strong>教程中遗漏了一点，是个大坑！弄出来的的日历没有样式，这是因为没有在文章中引入样式文件。这种文件是全局的，大致是这么个路径style.styl文件：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-650a0928b5dab56e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.jpg"></p></blockquote><h3 id="统计插件"><a href="#统计插件" class="headerlink" title="统计插件"></a>统计插件</h3><blockquote><p>统计插件用来统计网站的访问量和访客人数，做出来的效果大致如下：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-07eec43787e6806b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"><br>此插件的安装教程：<a href="https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/" target="_blank" rel="external">https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/</a></p></blockquote><h3 id="订阅插件"><a href="#订阅插件" class="headerlink" title="订阅插件"></a>订阅插件</h3><blockquote><p>此插件可以客观认为是个非常不起眼的装饰插件，不痛不痒，看个人需求，不过安装起来相比起来也非常简单，有兴趣的可以安装试一下，安装后的点击效果：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-3bdc15d6b819c866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"><br>此插件的安装教程：<a href="http://blog.csdn.net/u011303443/article/details/52333695" target="_blank" rel="external">http://blog.csdn.net/u011303443/article/details/52333695</a></p></blockquote><h3 id="音乐插件"><a href="#音乐插件" class="headerlink" title="音乐插件"></a>音乐插件</h3><blockquote><p>此插件也算是一种比较有意思的插件，安装起来也并不复杂，喜欢音乐的朋友可以弄一个，效果大致是这样：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-18afc1ea64f70004.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="07.png"><br>此插件的安装教程：<a href="http://blog.csdn.net/u013384788/article/details/74079890" target="_blank" rel="external">http://blog.csdn.net/u013384788/article/details/74079890</a></p></blockquote><p>More info: <a href="http://www.javait.club/2017/11/16/HexoArticle/" target="_blank" rel="external">Hexo写博客（一）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   关于个人博客网站的搭建，从&lt;a href=&quot;https://www.aliyun.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;域名&lt;/a&gt;的购买到绑定和注册&lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;，好文章确实很多，在此就不再做单独的个人文章说明，只分享前辈们“&lt;a href=&quot;http://blog.liuxianan.com/build-blog-website-by-hexo-github.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;搭建Hexo&lt;/a&gt;”的链接。本文的重点将落在各类Hexo插件的整合上，Hexo插件甚多，本文只介绍常见的几种。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程（一）</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/11/13/Thread/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/11/13/Thread/</id>
    <published>2017-11-13T15:52:20.000Z</published>
    <updated>2017-12-02T07:32:35.794Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin" target="_blank" rel="external">多线程</a>（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。[1]  在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理（Multithreading）”。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程（台湾译作“执行绪”），进而提升整体处理性能。<br><a id="more"></a></p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p><code>语法：public class A extends Thread{}</code></p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><code>语法：public class A implements Runnable{}</code></p><h3 id="开启线程"><a href="#开启线程" class="headerlink" title="开启线程"></a>开启线程</h3><ul><li><p>情形一：继承Thread类</p><blockquote><p><code>A a=new A();a.start();</code><br><code>说明：开启线程a，并等待执行a对象中的run()方法</code> </p></blockquote></li><li><p>情形二：实现Runnable接口</p><blockquote><p><code>A a=new A();Thread t=new Thread(a);t.start()</code><br><code>说明：开启线程t，并等待执行a对象中的run()方法</code> </p></blockquote></li></ul><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。<br>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。<br>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。</p></blockquote><h3 id="基本原则："><a href="#基本原则：" class="headerlink" title="基本原则："></a>基本原则：</h3><ul><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li></ul><h2 id="start-和-run-的区别说明"><a href="#start-和-run-的区别说明" class="headerlink" title="start() 和 run()的区别说明"></a>start() 和 run()的区别说明</h2><ul><li><strong>start() :</strong> 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</li><li><strong>run():</strong> run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</li></ul><h2 id="wait-notify-notifyAll-等方法介绍"><a href="#wait-notify-notifyAll-等方法介绍" class="headerlink" title="wait(), notify(), notifyAll()等方法介绍"></a>wait(), notify(), notifyAll()等方法介绍</h2><p>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p><ul><li>wait()：让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</li><li>notify()：唤醒在此对象监视器上等待的单个线程。即，唤醒具有同一个此对象锁且正处于等待中的“一个”线程。</li><li>notifyAll()：唤醒在此对象监视器上等待的所有线程。即，唤醒具有同一个此对象锁且正处于等待中的“所有”线程。</li></ul><h2 id="yield-与-wait-的比较"><a href="#yield-与-wait-的比较" class="headerlink" title="yield() 与 wait()的比较"></a>yield() 与 wait()的比较</h2><p>wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：</p><ul><li>wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而yield()是让线程由“运行状态”进入到“就绪状态”。</li><li>wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</li></ul><h2 id="sleep-与-wait-的比较"><a href="#sleep-与-wait-的比较" class="headerlink" title="sleep() 与 wait()的比较"></a>sleep() 与 wait()的比较</h2><blockquote><p>wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p></blockquote><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多线程&lt;/a&gt;（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。[1]  在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理（Multithreading）”。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程（台湾译作“执行绪”），进而提升整体处理性能。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>标识接口</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/24/MarkerInterface/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/24/MarkerInterface/</id>
    <published>2017-07-24T04:31:40.000Z</published>
    <updated>2017-11-25T05:24:52.561Z</updated>
    
    <content type="html"><![CDATA[<p>   “标识接口”是没有任何方法和属性的接口。标识接口不对实现它的类有任何语义上的要求，它仅仅表明实现它的类属于一个特定的类型。标接口在Java语言中有一些很著名的应用，比如java.io.Serializable、java.rmi.Remote和java.lang.Cloneable等接口便是标识接口。一个类实现了标识接口，那么这个类就被贴上了一个标签，相当于是归到了某个类别中。下面只讲两个标识接口Serializable和Cloneable。<br><a id="more"></a></p><h2 id="Serializable序列化"><a href="#Serializable序列化" class="headerlink" title="Serializable序列化"></a>Serializable序列化</h2><p>序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。序列化使其他代码可以查看或修改那些不序列化便无法访问的对象实例数据。即，将对象以一连串字节描述的过程。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统中，并在需要时把该流读取出来重新构造一个相同的对象。如果一个类能被序列化，那么它的子类也能够被序列化。Public Class A implements Serializable{}。使用案例：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-d01a32154ea95748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h2 id="Cloneable克隆"><a href="#Cloneable克隆" class="headerlink" title="Cloneable克隆"></a>Cloneable克隆</h2><p>Cloneable接口是一个空接口，仅用于标记对象，Cloneable接口里面是没有clone()方法，clone()方法是Object类里面的方法！如果对象implement Cloneable接口的话，需要覆盖clone方法（因为Object类的clone方法是protected，需要覆盖为public）。使用Cloneable接口的步骤：</p><ul><li>实现clone的类首先需要继承Cloneable接口；</li><li>在类中重写Object类中的clone()方法；</li><li>在clone方法中调用super.clone()。无论clone类的继承结构是什么，super.clone()都会直接或间接调用java.lang.Object类中的clone()方法；</li><li>把潜复制的引用指向原型对象新的克隆体。<br>使用案例：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-7257f1c534ab36ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-01.png"><br><strong>浅复制和深复制：</strong></li><li>浅复制：在JAVA中，浅复制是指当对象的字段值被复制时,字段引用的对象不会被复制.例如,如果一个对象有一个指向字符串的字段,并且我们对该对象做了一个浅复制,那麽两个对象将引用同一个字符串.和浅复制对应的有深复制.</li><li>深复制：是将指向内容复制到给当前对象新分配的缓冲区中的一种复制方式，相对于浅复制。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-702d17b279d10445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02-02.png"></li></ul><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   “标识接口”是没有任何方法和属性的接口。标识接口不对实现它的类有任何语义上的要求，它仅仅表明实现它的类属于一个特定的类型。标接口在Java语言中有一些很著名的应用，比如java.io.Serializable、java.rmi.Remote和java.lang.Cloneable等接口便是标识接口。一个类实现了标识接口，那么这个类就被贴上了一个标签，相当于是归到了某个类别中。下面只讲两个标识接口Serializable和Cloneable。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>方法“重写”和“重载”</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/23/FunctionChange/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/23/FunctionChange/</id>
    <published>2017-07-23T11:08:20.000Z</published>
    <updated>2017-11-24T06:00:46.466Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/java/85979?fr=aladdin&amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;fromid=4148931" target="_blank" rel="external">Java</a>中，继承和多态都是面向对象程序设计的特点。使用继承可以在一个父类的基础上再创建一个子类，这个子类不但拥有父类已有的属性和方法，还可以创建属于自己的属性和方法。由于子类和父类之间的关系，从而引出了方法重写和方法重载的问题。方法重写及方法重载在继承和多态性方面的应用中会存在很多问题，这些概念很容易混淆，掌握重写和重载的区别对学会使用多态的方式编写程序、提高程序的可维护性奠定了基础。</p><a id="more"></a><h2 id="方法重写-0veriding"><a href="#方法重写-0veriding" class="headerlink" title="方法重写(0veriding)"></a>方法重写(0veriding)</h2><h3 id="“重写”概念"><a href="#“重写”概念" class="headerlink" title="“重写”概念"></a>“重写”概念</h3><p>在Java程序中，类的继承关系可以产生一个子类，子类继承父类，它具备了父类所有的特征，继承了父类所有的方法和变量。子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写，也叫称为覆写或覆盖。<br><strong>抽取理解：</strong>一个类M继承另一个类N，N中有一个方法A，这时你在M写了一个方法B，方法B的名字、返回值以及参数都和A一样，此时B重写了A。</p><h3 id="“重写”案例"><a href="#“重写”案例" class="headerlink" title="“重写”案例"></a>“重写”案例</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-1f879b08f8b96794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h3 id="“重写”要素"><a href="#“重写”要素" class="headerlink" title="“重写”要素"></a>“重写”要素</h3><ul><li>函数名与形参列表必须一直；</li><li>子类的权限修饰符必须&gt;=父类的权限修饰符；</li><li>子类的返回值类型&lt;=父类的返回值类型；</li><li>子类抛出的异常类型&lt;=父类抛出的异常类型。</li></ul><h2 id="方法重载-0veriding"><a href="#方法重载-0veriding" class="headerlink" title="方法重载(0veriding)"></a>方法重载(0veriding)</h2><h3 id="“重载”概念"><a href="#“重载”概念" class="headerlink" title="“重载”概念"></a>“重载”概念</h3><p>所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。方法的重载在实际应用中也会经常用到。不仅是一般的方法，构造方法也可以重载。<br><strong>抽取理解：</strong>一个类中有一个方法A，你又在这个类中创建了一个方法B，方法B的名字和A一样，返回值类型也一样，但是参数的类型或个数不同，此时B重载了A。</p><h3 id="“重载”案例"><a href="#“重载”案例" class="headerlink" title="“重载”案例"></a>“重载”案例</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-a2124716538ae794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><h3 id="“重载”要素"><a href="#“重载”要素" class="headerlink" title="“重载”要素"></a>“重载”要素</h3><ul><li>函数名一致；</li><li>形参列表不一致，形参个数或数据类型不一致；</li><li>与函数返回值类型及有无返回值无关；</li></ul><h2 id="方法“重写”与“重载”的区别"><a href="#方法“重写”与“重载”的区别" class="headerlink" title="方法“重写”与“重载”的区别"></a>方法“重写”与“重载”的区别</h2><p>在面向对象程序设计的思想中，类的继承和多态性主要就是体现在子类重写父类的方法。而构造方法的重载作为方法重载的一个典型特例，可以通过重载构造方法来表达对象的多种初始化行为。灵活的运用方法重写与方法重载，不仅能减少编码的工作量，也能大大提高程序的可维护性及可扩展性。以下是两者的差别：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-0e26bfbf58cdc7cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><p>More info: <a href="http://www.javait.club/2017/07/22/EndLoop/" target="_blank" rel="external">return、break及continue</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/java/85979?fr=aladdin&amp;amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;amp;fromid=4148931&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;中，继承和多态都是面向对象程序设计的特点。使用继承可以在一个父类的基础上再创建一个子类，这个子类不但拥有父类已有的属性和方法，还可以创建属于自己的属性和方法。由于子类和父类之间的关系，从而引出了方法重写和方法重载的问题。方法重写及方法重载在继承和多态性方面的应用中会存在很多问题，这些概念很容易混淆，掌握重写和重载的区别对学会使用多态的方式编写程序、提高程序的可维护性奠定了基础。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Json对象</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/23/Json/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/23/Json/</id>
    <published>2017-07-23T08:09:10.000Z</published>
    <updated>2017-12-02T07:33:02.846Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin" target="_blank" rel="external">JSON</a>(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。Json数据是跨平台的，在网络数据传输流程中，json是以文本，即字符串的形式传递的，各种语言对字符串的处理比较统一。而在JS是对象的形式。<br><a id="more"></a></p><h2 id="Json的三种数据格式"><a href="#Json的三种数据格式" class="headerlink" title="Json的三种数据格式"></a>Json的三种数据格式</h2><h3 id="对象格式-name-value-name-value"><a href="#对象格式-name-value-name-value" class="headerlink" title="对象格式{name:value,name:value}"></a>对象格式{name:value,name:value}</h3><p><code>案例：var pp={&quot;id&quot;:10,&quot;name&quot;:&quot;lisi&quot;,.......}</code><br><strong>注意：</strong>在json数据格式中,name类型是字符串，value类型是Object。</p><h3 id="数组格式-元素，元素，元素"><a href="#数组格式-元素，元素，元素" class="headerlink" title="数组格式[元素，元素，元素]"></a>数组格式[元素，元素，元素]</h3><p><code>案例：var pp=[{&quot;name&quot;:&quot;Michael&quot;,&quot;age&quot;:24}，{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:25}]</code><br><strong>注意：</strong>取值方式，通过pp[0].name取值，值为Michael。</p><h3 id="组合格式（嵌套）"><a href="#组合格式（嵌套）" class="headerlink" title="组合格式（嵌套）"></a>组合格式（嵌套）</h3><p><code>案例：{&quot;name&quot;:&quot;Michael&quot;, &quot;birthday&quot;:{&quot;month&quot;:8,&quot;day&quot;:26}}</code></p><h2 id="Json需要的jar"><a href="#Json需要的jar" class="headerlink" title="Json需要的jar"></a>Json需要的jar</h2><p>在java中使用json需要引入以下几个jar包，否则会报错：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-7099c078f623034e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h2 id="Json常用的两种方法"><a href="#Json常用的两种方法" class="headerlink" title="Json常用的两种方法"></a>Json常用的两种方法</h2><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><p>说明：JSON.stringify()将JSON对象转为JSON字符串（序列化）</p><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><p>说明：JSON.parse()将JSON字符串转为JSON对象（反序列化）<br><strong>注意：</strong>springmvc中提供对请求参数的封装，如果请求数据为json格式，需要封装在javabean之中，那么这个javaBean需要实现Serializable接口，具备序列化的特点。</p><h2 id="Json数据校验"><a href="#Json数据校验" class="headerlink" title="Json数据校验"></a>Json数据校验</h2><p>众所周知，如果Json数据有几百行或者几万行代码组成，那么就会是一长串的“字符串”，很难找到或定位自己所需要的数据，同时也不能确定，此Json数据不存在语法错误，所以就需要对Json数据进行校验和格式化。</p><h3 id="JSON数据校验"><a href="#JSON数据校验" class="headerlink" title="JSON数据校验"></a>JSON数据校验</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-06ea57911748a742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"><br>工具网址：<a href="https://www.bejson.com/" target="_blank" rel="external">https://www.bejson.com/</a></p><h3 id="Json数据格式化"><a href="#Json数据格式化" class="headerlink" title="Json数据格式化"></a>Json数据格式化</h3><p><img src="http://upload-images.jianshu.io/upload_images/9194313-3c8ab3330a5b6657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br>工具地址：<a href="https://www.bejson.com/jsonviewernew/" target="_blank" rel="external">https://www.bejson.com/jsonviewernew/</a></p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/JSON/2462549?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSON&lt;/a&gt;(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。Json数据是跨平台的，在网络数据传输流程中，json是以文本，即字符串的形式传递的，各种语言对字符串的处理比较统一。而在JS是对象的形式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>continue/break/return</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/22/EndLoop/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/22/EndLoop/</id>
    <published>2017-07-22T10:55:47.000Z</published>
    <updated>2017-11-24T06:04:12.330Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/java/85979?fr=aladdin&amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;fromid=4148931" target="_blank" rel="external">Java</a>中，这三个关键字都具备着特殊的含义，都拥有着能结束或停止循环的作用，下面对这三个关键字的作用范围以及使用方式做明确讲解，总的来说范围大小是return&gt;break&gt;continue。这三者的考量在某些笔试题目中也经常出现，所以需要引起重视，下面开始对三者进行讲解。</p><a id="more"></a><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p><strong>return语句的作用：</strong></p><ul><li>return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行；</li><li>return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致，可以使用强制类型转换来是数据类型一致；</li><li>return 当方法说明中用void声明返回类型为空时，应使用这种格式，不返回任何值。（在js中，函数不声明返回值也可以使用return）</li></ul><p><strong>代码案例：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9194313-545f02248dd7197d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"><br><strong>总结：</strong>“return”关键字作用范围是其所在的方法，作用是结束方法体，要么返回“值”，要没不返回“值”，如案例所示。</p><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p><strong>break语句的作用</strong></p><ul><li>只能在循环体内和switch语句体内使用break语句；</li><li>当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体；</li><li>当break出现在循环体中，但并不在switch语句体内时，则在执行break后，跳出本层循环体；</li><li>在循环结构中，应用break语句使流程跳出本层循环体，从而提前结束本层循环。</li></ul><p><strong>代码案例：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9194313-1d3fa75f9fff4a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"><br><strong>总结：</strong>“break”关键字用于switch语句，用来结束switch语句；用于for循环，作用就是终止循环体。</p><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p><strong>continue语句的作用：</strong></p><ul><li>结束本次循环，即跳过本次循环体中余下尚未执行的语句，接着再一次进行循环的条件判定；</li><li>执行continue语句并没有使整个循环终止。在while和do-while循环中，continue语句使得流程直接跳到循环控制条件的测试部分 ，然后决定循环是否继续进行；</li><li>在for 循环中，遇到continue后，跳过循环体中余下的语句，而去对for语句中的“表达式3”求值，然后进行“表达式2”的条件测试。</li></ul><p><strong>代码案例：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9194313-aa572e30c6990d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"><br><strong>总结：</strong>“continue”关键字作用范围是本次循环，作用就是结束本次循环，开始下次循环，即开始“i+1”的循环。</p><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/java/85979?fr=aladdin&amp;amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;amp;fromid=4148931&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;中，这三个关键字都具备着特殊的含义，都拥有着能结束或停止循环的作用，下面对这三个关键字的作用范围以及使用方式做明确讲解，总的来说范围大小是return&amp;gt;break&amp;gt;continue。这三者的考量在某些笔试题目中也经常出现，所以需要引起重视，下面开始对三者进行讲解。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC常用注解</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/21/SpringMvcAnotation/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/21/SpringMvcAnotation/</id>
    <published>2017-07-21T08:09:10.000Z</published>
    <updated>2017-11-27T10:19:26.607Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/spring%20MVC/5627187?fr=aladdin" target="_blank" rel="external">SpringMVC</a>属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能MVC模块。使用Spring可插入的MVC架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1，Struts2等。本章主要讲开发中，常用注解。<br><a id="more"></a></p><h2 id="SpringMVC常用注解"><a href="#SpringMVC常用注解" class="headerlink" title="SpringMVC常用注解"></a>SpringMVC常用注解</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。基于注解的Controller可以支持同时处理多个请求动作，并且无需实现任何接口。<br>使用案例：<br><code>@Controller</code><br><code>public class MyController{}</code></p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping指定指示Spring用哪一个类或方法来处理请求动作，该注解可以用在类或方法上。<br>常用属性：</p><ul><li>value属性：将URL请求路径映射到方法上。<blockquote><p><code>@RequestMapping（value=&quot;/hello&quot;）</code><br><code>public String helloSpring(){};</code></p></blockquote></li><li>method属性：标示该方法只能处理哪些HTTP请求，没写该属性，默认都支持。<blockquote><p><code>@RequestMapping（value=&quot;/hello&quot;,method=RequestMethod.POST）</code><br><code>public String helloSpring(){};</code></p></blockquote></li><li>consumes（produces）属性：指定请求（或返回）的数据类型。<blockquote><p><code>@RequestMapping（value=&quot;/hello&quot;,method=RequestMethod.POST，consumes=&quot;application/json&quot;）</code><br><code>public String helloSpring(){};</code></p></blockquote></li></ul><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>@RequestParam用于将制定的请求参数赋值给方法中的形参。<br>案例：</p><blockquote><p><code>请求路径:http://www.javait/club?name=kack&amp;password=123456</code><br><code>参数绑定:public String helloSpring(@RequestParam(value=&quot;password&quot;) String pwd){......}</code></p></blockquote><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>@CookieValue用于将请求的Cookie数据映射到功能方法的参数上。</p><blockquote><p><code>@CookieValue（value=&quot;JESSIONID&quot;）String pwd</code></p></blockquote><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>@PathVariable获取请求URL中的动态参数<br>案例：</p><blockquote><p><code>请求路径:http://www.javait/club/hello/1</code><br><code>@RequestMapping（value=&quot;/hello/{userId}&quot;,method=RequestMethod.POST）</code><br><code>参数绑定:public String helloSpring(@PathVariable Integer userId){......}</code></p></blockquote><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody接受JSON格式的数据，并将其转换为对应的数据类型。<br>案例：</p><blockquote><p><code>请求data:JSON.stringify({&quot;id&quot;:10,&quot;name&quot;:&quot;lisi&quot;})</code><br><code>参数绑定:public String helloSpring(@RequestBody User user){....}</code></p></blockquote><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@RequestBody将数据转成json格式返回客户端<br>案例：</p><blockquote><p><code>加载方法上:@ResponseBody</code><br><code>加载方法返回值处:public @ResponseBody User helloSpring(){.....return user;}</code></p></blockquote><p>More info: <a href="http://www.javait.club/" target="_blank" rel="external">首页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/spring%20MVC/5627187?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SpringMVC&lt;/a&gt;属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能MVC模块。使用Spring可插入的MVC架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1，Struts2等。本章主要讲开发中，常用注解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java之排序方法</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/21/SortOrder/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/21/SortOrder/</id>
    <published>2017-07-21T07:41:02.000Z</published>
    <updated>2017-11-24T05:56:35.304Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/java/85979?fr=aladdin&amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;fromid=4148931" target="_blank" rel="external">Java</a>中常用的最基本的几种排序方式代码还是要记住的，代码内容都不是很多，但是代码所表达的意义都非常经典，也是各大考官或笔试常见问题点，所以有必要做个了结。关于简单的流程控制语句if/else if/switch/while/do while/for等等，这类基本的循环语句在此就不做讲解了。<br><a id="more"></a></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。算法实现：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-2deadfe43364fffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><blockquote><p><strong>算法原理：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9194313-0e0933035d47bc73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p><p><strong>算法实现：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9194313-75e49e0b57a06247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p></blockquote><p>More info: <a href="http://www.javait.club/2017/07/20/DesignPatterns/" target="_blank" rel="external">Java之设计模式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/java/85979?fr=aladdin&amp;amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;amp;fromid=4148931&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;中常用的最基本的几种排序方式代码还是要记住的，代码内容都不是很多，但是代码所表达的意义都非常经典，也是各大考官或笔试常见问题点，所以有必要做个了结。关于简单的流程控制语句if/else if/switch/while/do while/for等等，这类基本的循环语句在此就不做讲解了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java之设计模式</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/20/DesignPatterns/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/20/DesignPatterns/</id>
    <published>2017-07-20T11:28:36.000Z</published>
    <updated>2017-11-24T05:29:44.616Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/java/85979?fr=aladdin&amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;fromid=4148931" target="_blank" rel="external">Java</a>中的设计模式有很多种，初级接触的到的有以下几种：单例模式、工厂模式、适配器模式和装饰模式等。下面主要对以上四种模式进行简单讲解：</p><a id="more"></a><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>作用：保证在整个程序的声明周期中，一个类在内存中只有一个对象。单例模式分为两种：饿汉式单例和懒汉式单例。</p><blockquote><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><p>解读：在类加载时，不管用不用到这个类的对象，程序在加载该类时都会为之创建一个对象。标准模型：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-92200e0d6276f5d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><p>解读：在类加载时，先声明类的静态成员，并赋予空值。在程序运行过程中，创建此类的对象前先判断此类的对象是否为空，如果为空就New,否者就不创建新的对象。标准模型：<br><img src="http://upload-images.jianshu.io/upload_images/9194313-8d820f35fb39a96e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p></blockquote><p>注意事项：（1）构造方法和成员变量都是private，只有一个public方法；（2）成员和方法都是static类型，在内存中只维护一份。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>作用：专门负责实例化有大量公共接口的类，以替代new操作。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-81fa7feb77250313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>作用：把一个类的接口转换成客户端所期望的另一种接口，从而使原本因为接口不匹配而无法一起工作的两个类能够一起工作。<br><img src="http://upload-images.jianshu.io/upload_images/9194313-73ed414772751403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04.png"><br>简单说明：我们都知道，实现一个接口就需要实现接口里面的所有方法，否则只实现部分方法那就不叫“实现”了。那么如果想达到实现接口中部分方法的目的，就需要用到这种适配器模式。具体操作：抽象类实现接口中所有方法，目标类继承此抽象类，重写部分所需方法。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>作用：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。关于装饰者模式的解读，有篇文章确实写的非常不错，看了很多文章，就这篇还可以，很简明。装饰者模式，有点类似于aop编程。<br>装饰者模式博客链接：<a href="http://www.cnblogs.com/chenssy/archive/2013/05/23/3094138.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/archive/2013/05/23/3094138.html</a></p><p>More info: <a href="http://www.javait.club/2017/07/23/FunctionChange/" target="_blank" rel="external">方法“重载”和“重写”</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/java/85979?fr=aladdin&amp;amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;amp;fromid=4148931&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;中的设计模式有很多种，初级接触的到的有以下几种：单例模式、工厂模式、适配器模式和装饰模式等。下面主要对以上四种模式进行简单讲解：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java基本语法</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/20/JavaDay02/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/20/JavaDay02/</id>
    <published>2017-07-20T08:04:36.000Z</published>
    <updated>2017-11-24T05:25:44.598Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/java/85979?fr=aladdin&amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;fromid=4148931" target="_blank" rel="external">Java</a>语法和C++语法相同之处很多，所以学习一门语言再跳另一门，还是会有很大帮助的。本章主要介绍java的基本语法和数据类型，章节重点主要是数据类型和运算符的掌握。面试和笔试的主要考察点一个是运算符的优先级别表，一个是基本数据类型的强转两个方面，所以请读者面试前重点做准备。</p><a id="more"></a><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a><a href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6/7105638?fr=aladdin" target="_blank" rel="external">标识符</a></h2><p>在日常生活中，标示符是用来指定某个东西、人，要用到它，他或她的名字；在数学中解方程时，我们也常常用到这样或那样的变量名或函数名；在编程语言中，标识符是用户编程时使用的名字，对于变量、常量、函数、语句块也有名字；我们统统称之为标识符。</p><blockquote><p>命名规范：(1)标识符由字母（A-Z,a-z）、数字（0-9）、下划线“_”和美元符号($)组成，并且首字符不能是数字，其他均可；(2)严格区分大小写，但是长度可以任意；(3)关键字(java中具有特殊含义的单词)、保留字不能用于自定义的标识符。</p></blockquote><p><strong>自定义标识符的规范：</strong></p><ul><li>类名和接口的单词首字母大写，其他字母小写；</li><li>变量名与方法名首单词全部小写，其他单词首字母大写；</li><li>包名全部小写；</li><li>常量名全部大写，单词之间用_下划线隔开。<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li><li><code>单行注释：//注释内容</code></li><li><code>多行注释：/*注释内容*/</code></li><li><code>文档注释：/**注释内容*/，生成开发者文档</code></li><li><code>生成文档注释的方式：控制台输入,javadoc -d 存放文档的路径 java源文件</code></li></ul><h2 id="数据类型（基本-引用）"><a href="#数据类型（基本-引用）" class="headerlink" title="数据类型（基本+引用）"></a>数据类型（基本+引用）</h2><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><blockquote><p><code>整型（byte/short/int/long,分别占8bit/16bit/32bit/64bit）</code><br><code>浮点型float/double，分别占32bit/64bit</code><br><code>布尔型boolean，描述基本类型变量32bit,数组元素8bit</code><br><code>字符型char,占16Bit</code></p></blockquote><p><strong>注意：</strong></p><ul><li>一个整数没有任何标示，默认是int类型；</li><li>一个浮点型没加任何标示，默认是double型；</li><li>一个汉字或者标点占2byte，一个英文或标点占1byte；</li><li>字符char，’0~9’对应48~57，a对应97，A对应65.</li></ul><h3 id="引用数据类型（String）"><a href="#引用数据类型（String）" class="headerlink" title="引用数据类型（String）"></a>引用数据类型（String）</h3><blockquote><p>C++、java、VB等编程语言中的字符串。 在java、C#中，String类是不可变的，对String类的任何改变，都是返回一个新的String类对象。 String 对象是 System.Char 对象的有序集合，用于表示字符串。String 对象的值是该有序集合的内容，并且该值是不可变的。</p></blockquote><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>小数据类型—&gt;大数据类型：自动类型转换；</li><li>大数据累心—&gt;小数据类型：强制转换；</li><li>转换细则：<blockquote><p>（1）凡是byte/short/char类型数据，在运算时都会自动转换为int类型；<br>（2）两个不同数据类型的数据运算的时候，结果取决于大的数据类型；<br>（3）java编译器在编译的过程中，只会检测数据是否超过变量类型的范围，并允许赋值或报错，赋值是在运算过程中进行的；<br>（4）使用“+=”运算会自动进行类型转换。</p></blockquote></li></ul><h2 id="运算符及优先级"><a href="#运算符及优先级" class="headerlink" title="运算符及优先级"></a>运算符及优先级</h2><p><img src="http://upload-images.jianshu.io/upload_images/9194313-fb2bedebf0756a0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.jpg"></p><hr><h2 id="面试、笔试点总结"><a href="#面试、笔试点总结" class="headerlink" title="面试、笔试点总结"></a>面试、笔试点总结</h2><ul><li>运算符优先级别考察；</li><li>强制类型转换</li><li>正负数的二进制存储形式（正数，源码；负数，补码）</li><li>boolean型数据占几个字节（汉字、字母占字节）</li></ul><p>More info: <a href="http://www.javait.club/2017/07/21/SortOrder/" target="_blank" rel="external">Java之排序方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/java/85979?fr=aladdin&amp;amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;amp;fromid=4148931&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;语法和C++语法相同之处很多，所以学习一门语言再跳另一门，还是会有很大帮助的。本章主要介绍java的基本语法和数据类型，章节重点主要是数据类型和运算符的掌握。面试和笔试的主要考察点一个是运算符的优先级别表，一个是基本数据类型的强转两个方面，所以请读者面试前重点做准备。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java简介</title>
    <link href="https://github.com/SpringEE/SpringEE.github.io/2017/07/19/JavaDay01/"/>
    <id>https://github.com/SpringEE/SpringEE.github.io/2017/07/19/JavaDay01/</id>
    <published>2017-07-19T11:28:36.000Z</published>
    <updated>2017-11-24T05:23:03.167Z</updated>
    
    <content type="html"><![CDATA[<p>   <a href="https://baike.baidu.com/item/java/85979?fr=aladdin&amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;fromid=4148931" target="_blank" rel="external">Java</a>是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程.</p><a id="more"></a><h2 id="计算机语言的发展史"><a href="#计算机语言的发展史" class="headerlink" title="计算机语言的发展史"></a>计算机语言的发展史</h2><ul><li>机器语言：0101001001(有0和1组合而成的二进制指令)</li><li>汇编语言：通过大量的英文单词代表计算机指令。add 1 1</li><li>高级语言：C\JAVA\C++\PHP </li></ul><h2 id="Java语言执行原理图："><a href="#Java语言执行原理图：" class="headerlink" title="Java语言执行原理图："></a>Java语言执行原理图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/9194313-01295da5924be963.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p><h2 id="人类与计算机的交互方式："><a href="#人类与计算机的交互方式：" class="headerlink" title="人类与计算机的交互方式："></a>人类与计算机的交互方式：</h2><ul><li><p>图形化界面的交互方式：简单、功能强大；</p></li><li><p>通过dos命令进行交互：功能弱小、需记忆大量dos命令。</p></li></ul><ul><li><strong>常见的dos命令</strong>（系统控制台窗口执行“windows+r”快捷打开）：<br><code>dir:列出当前路径下的所有文件和文件夹</code><br><code>cd f://java/....：进入指定的路径下</code><br><code>cd ..：返回上级目录</code><br><code>cd \:回退到当前目录的根目录</code><br><code>md 文件夹:新建文件夹</code><br><code>rd 文件夹:删除文件夹</code><br><code>echo 数据&gt;文件：将“数据”写入“文件”中</code><br><code>type 文件名：查看指定文件的内容</code><br><code>del 文件名：删除指定文件</code><br><code>cls：清屏</code><br><code>exit：关闭控制台</code></li></ul><h2 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h2><h3 id="配置path环境变量"><a href="#配置path环境变量" class="headerlink" title="配置path环境变量"></a>配置path环境变量</h3><blockquote><ul><li><p>位置：我的电脑–属性–高级系统设置–高级–环境变量–path</p></li><li><p>目的：使控制台可以在任意路径下找到java的开发工具</p></li><li><p>方式：新建你要配置的环境变量名，然后将其加入到path环境变量中，加入方式，Path=%环境变量名%。</p></li></ul></blockquote><h3 id="配置set临时环境变量"><a href="#配置set临时环境变量" class="headerlink" title="配置set临时环境变量"></a>配置set临时环境变量</h3><p>使环境变量只在当前控制台有效，调试或测试时使用。set环境变量语法：</p><ul><li> <code>set  查看所有的环境变量信息</code></li><li><code>set 环境变量名  查看指定环境变量信息</code></li><li><code>set 环境变量名=路径  设置临时环境变量</code></li><li><code>set 环境变量名=  清空环境变量</code></li><li><code>set 环境变量名=路径；%JAVA_HOME%  在路径基础上拼接新路径</code></li></ul><h3 id="配置classpath临时环境变量"><a href="#配置classpath临时环境变量" class="headerlink" title="配置classpath临时环境变量"></a>配置classpath临时环境变量</h3><p>配置classpath环境变量，是为了设置.class文件的路径信息。启动java虚拟机时，jvm只会在classpath路径下去找对应的.class文件。如果在classpath路径后追加“；”，先找classpath，找不到再找当前路径下的.class文件。</p><hr><p>总结：此部分的大多数的内容都属于了解，了解的目的是在碰到时能会用，并能快速上手，记忆的话，如果你有实力，可以考虑强行记忆，都是有用的，了解即可。下面来介绍本章常见的一些面试问题。</p><hr><h2 id="常见面试问题及知识点："><a href="#常见面试问题及知识点：" class="headerlink" title="常见面试问题及知识点："></a>常见面试问题及知识点：</h2><p>1.Java虚拟机跨平台吗？</p><blockquote><p>答：不跨。java语言是跨平台的，“一次编译，到处运行”。但是JVM虚拟机就相当于一个简单的应用的程序，用来解释并执行.class文件，不同的系统平台所支持的应用类型是不同的，所以这个“应用”很显然不能跨平台。一个平台，一个虚拟机。</p></blockquote><p>2.配置path环境变量的目的？</p><blockquote><p>答：使控制台可以在任意路径下找到java的开发工具</p></blockquote><p>3.Java和C/C++有何异同？</p><blockquote><p>答：相同点，Java和C++都是面向对象编程的语言。不同点，（1）java是解释性语言，C++是编译型语言，所以java能够跨平台，C++不能跨平台；（2）Java是纯面向对象的语言，而C++兼具面向对象和面向过程变成的特点；（3）Java是“单继承，多实现”，而C++是支持多继承的；（4）C++内存管理需要开发人员分配，而Java的垃圾回收机制自动进行内存管理。</p></blockquote><p>4.一个Java文件中是否可以定义多个类？</p><blockquote><p>答：一个java文件中可以定义多个类，但是最多只有一个类被public修饰，并且这个类的类名与文件名必须相同。当对.java文件进行编译时，它会给文件中的每个类都生成一个.class文件，即生成两个字节码文件。</p></blockquote><p>5.面向对象与面向过程的区别？</p><blockquote><p>答：面向对象，只关注对象本身，不关注怎么实现，处理的是“让谁做”；面向过程，重点是关注过程的实现和逻辑结构，处理的是“该怎么做”。</p></blockquote><p>6.面向对象的三个特征及优点？</p><blockquote><p>答：封装、继承和多态。优点：（1）较高的开发效率；（2）较高的代码复用性；（3）保证了软件的高维护性。</p></blockquote><p>More info: <a href="http://www.javait.club/2017/07/20/JavaDay02/" target="_blank" rel="external">Java基本语法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   &lt;a href=&quot;https://baike.baidu.com/item/java/85979?fr=aladdin&amp;amp;fromtitle=Java%E8%AF%AD%E8%A8%80&amp;amp;fromid=4148931&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java&lt;/a&gt;是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
